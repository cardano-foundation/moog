"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[2129],{7682:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"dev/code-design","title":"Code Design Decisions","description":"opt-env-conf vs optparse-applicative","source":"@site/docs/dev/code-design.md","sourceDirName":"dev","slug":"/dev/code-design","permalink":"/moog/docs/dev/code-design","draft":false,"unlisted":false,"editUrl":"https://github.com/cardano-foundation/moog/tree/main/docs/docs/dev/code-design.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Architecture Overview","permalink":"/moog/docs/ops/architecture"}}');var s=t(4848),a=t(8453);const i={},r="Code Design Decisions",c={},d=[{value:"opt-env-conf vs optparse-applicative",id:"opt-env-conf-vs-optparse-applicative",level:2},{value:"Commands as GADTs",id:"commands-as-gadts",level:2},{value:"Parsing commands",id:"parsing-commands",level:2},{value:"Existential boxing of the command results",id:"existential-boxing-of-the-command-results",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"code-design-decisions",children:"Code Design Decisions"})}),"\n",(0,s.jsx)(n.h2,{id:"opt-env-conf-vs-optparse-applicative",children:"opt-env-conf vs optparse-applicative"}),"\n",(0,s.jsx)(n.p,{children:"Optparse-applicative is a popular library for parsing command-line options in Haskell. It provides a declarative way to define command-line interfaces and supports features like subcommands, flags, and arguments."}),"\n",(0,s.jsx)(n.p,{children:"Opt-env-conf is a library that extends optparse-applicative by adding support for environment variables and configuration files. It allows developers to define options that can be set via command-line arguments, environment variables, or configuration files, providing more flexibility in how applications can be configured."}),"\n",(0,s.jsx)(n.p,{children:"We chose to use opt-env-conf over optparse-applicative for the following reasons:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Some commands require some env vars to be set, while others don't. opt-env-conf allows us to handle this complexity more gracefully, wihout passing around Maybe values."}),"\n",(0,s.jsx)(n.li,{children:"We need to handle both encrypted and unencrypted mnemonics. Depending on that the settings are different. opt-env-conf allows us to define different settings based on the context, making it easier to manage these variations. In particular after parsing the env var MOOG_WALLET_FILE we insert a read-only operation (checkMapIO) that brings in the fields of the wallet file as settings. Depending on the field we require different settings for the passphrase."}),"\n",(0,s.jsxs)(n.li,{children:["We want to support interactive prompts for sensitive information like passwords. opt-env-conf ",(0,s.jsx)(n.code,{children:"mapIO"})," allows us to introduce interactive prompts as part of the settings parsing process, making it easier to handle user input securely."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"commands-as-gadts",children:"Commands as GADTs"}),"\n",(0,s.jsx)(n.p,{children:"All commands are reified as GADTs where"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"each constructor represents a command"}),"\n",(0,s.jsx)(n.li,{children:"the fields of the constructor are the arguments of the command"}),"\n",(0,s.jsx)(n.li,{children:"the return type of the constructor is the return type of the command"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By using GADTs it's possible to have a different output type for each command."}),"\n",(0,s.jsxs)(n.p,{children:["To structure the commands we use subcommands. Higher level commands just wraps the lower level ones. For example the ",(0,s.jsx)(n.code,{children:"moog wallet"})," command is a subcommand of the ",(0,s.jsx)(n.code,{children:"moog"})," command and the ",(0,s.jsx)(n.code,{children:"moog wallet create"})," command is a subcommand of the ",(0,s.jsx)(n.code,{children:"moog wallet"})," command."]}),"\n",(0,s.jsx)(n.p,{children:"Thanks to GADTs the high level commands can just demandate the output type of the lower level commands and return it as their own output type."}),"\n",(0,s.jsx)(n.h2,{id:"parsing-commands",children:"Parsing commands"}),"\n",(0,s.jsxs)(n.p,{children:["The parsing of the commands is done using the ",(0,s.jsx)(n.code,{children:"opt-env-conf"})," library. See the ",(0,s.jsx)(n.a,{href:"https://hackage.haskell.org/package/opt-env-conf",children:"opt-env-conf documentation"})," for more details."]}),"\n",(0,s.jsxs)(n.p,{children:["Command parsers for the same GADTs compose via the ",(0,s.jsx)(n.code,{children:"Alternative"})," typeclass. This means that each command parser can be defined independently and then combined together to form the full command parser."]}),"\n",(0,s.jsxs)(n.p,{children:["Arguments parsers compose via the ",(0,s.jsx)(n.code,{children:"Applicative"})," typeclass. This means that each argument parser can be defined independently and then combined together to form the full command parser for a command."]}),"\n",(0,s.jsx)(n.h3,{id:"existential-boxing-of-the-command-results",children:"Existential boxing of the command results"}),"\n",(0,s.jsxs)(n.p,{children:["Because each command can have a different return type, we need to box the result of the command in an existential type. This is done using the ",(0,s.jsx)(n.code,{children:"Box"})," type. The ",(0,s.jsx)(n.code,{children:"Box"})," allows only for results that can be rendered as canonical JSON."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Box"})," has a form of fmapping called ",(0,s.jsx)(n.code,{children:"fmapBox"})," that allows to transform the inner value of the box while keeping the box type. This is useful when creating options for high level commands that just wrap lower level commands."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var o=t(6540);const s={},a=o.createContext(s);function i(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);
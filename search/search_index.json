{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>Moog is still at an early stage and experimental. Contributions and ideas are most welcome.</p>"},{"location":"#moog","title":"Moog","text":"<p>Testing Cardano on Cardano with Antithesis</p> <p>Moog is a portal to the Antithesis service. It makes it possible for an organisation that has an Antithesis licence to provide to other users the opportunity to submit their own Antithesis tests, which will then be run by the organisation that has access to Antithesis. The details of this transaction is then stored on the Cardano blockchain.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>We call users of Moog the people who wish to submit requests for an Antithesis test to be run. They should read the User Manual.</p> <p>We call operators of Moog the people who are providing a portal to their Antithesis instance. This involves setting up some infrastructure, running automated services, as well as having human agents performing occasional tasks. This is all described in the Operations Manual.</p>"},{"location":"#about","title":"About","text":"<p>In particular, the Cardano Foundation is currently operating the prototype implementation of a Moog portal to allow developers within the Cardano ecosystem to use run Antithesis tests, in an effort to contribute to improving the quality of software within the Cardano ecosystem.</p>"},{"location":"blog/","title":"Blog","text":"<p>Welcome to the Moog project blog. Here we share updates, findings, and news about the Antithesis testing platform for Cardano.</p>"},{"location":"blog/2025-04-02-kick-off-antithesis/","title":"Cardano / Antithesis Project Kick-off","text":"<p>Already involved in testing and monitoring the Cardano network infrastructure, the Cardano Foundation has decided to dedicate resources to evaluate if and how Antithesis could increase the reach and level of quality assurance the network needs.</p> <p>This post introduces the project, its motivations, scope, ambitions, and timeline.</p>"},{"location":"blog/2025-04-02-kick-off-antithesis/#why-this-project","title":"Why this project?","text":"<p>The teams implementing the cardano-node have developed over the years an extensive set of tools, including sophisticated simulation and model-based testing systems</p> <p>Testing distributed systems at scale is a hard problem, poses unique challenges in terms of tools, scenarios generation, reproducibility, failure analysis, and it requires deep expertise and a significant investment to be effective.</p> <p>As exemplified by the continued successes of Jepsen reports over the past decade, rigorous system-level blackbox testing with fault injections and sophisticated traces analysis can uncover subtle concurrency bugs and security vulnerabilities. However, such tests can quickly be expensive to setup even with virtualised infrastructure, take a lot of time to execute, and are hard to reproduce.</p> <p>Simulation testing, whereby a piece of software is tested in an environment which simulates its actual execution target to provide better control and allow exploring a lot of scenarios including fault injections, is a quite old technique. The success the FoundationDB team had applying this technique sparked the development of Antithesis, a generic platform for simulation testing of distributed systems.</p> <p>As the ecosystem grows to include new and different \"nodes\" in the network like Dolos, Dingo, Amaru, and many tools and systems building on Cardano core infrastructure, the need arises to investigate how to provide similar system-level testing tools in a language-agnostic way, tools that could be used by the whole community to investigate more scenarios in a more diverse environment.</p>"},{"location":"blog/2025-04-02-kick-off-antithesis/#what-is-antithesis","title":"What is Antithesis?","text":"<p>In short, Antithesis is a platform combining:</p> <ol> <li>A deterministic hypervisor that can run nearly arbitrary pieces of software, emulating the full complexity of the underlying operating system and network, including the ability to simulate the passing of time,</li> <li>Property-based testing and fuzzing to deterministically generate complex test scenarios and check observable properties of the system-under-test, with the ability to reproduce failures,</li> <li>Analysis and reporting tools to help troubleshoot issues signaled by tests run.</li> </ol> <p>The team is responsible for packaging the system-under-test as a \"cluster\" of containers running and interacting within the simulated environment provided by the platform, for providing test clients and scenarios to explore, and for defining \"interesting\" properties to verify.</p> <p>Here is a diagram from antithesis' website summarizing how the platform works:</p> <p></p>"},{"location":"blog/2025-04-02-kick-off-antithesis/#what-is-this-project-about","title":"What is this project about?","text":"<p>While we strongly believe in the effectiveness of this approach especially as new components get developed, network grows, and new features are added to the protocol, and Antithesis has already been adopted by industry leaders like Confluent or Ethereum, we want to understand how this investment can yield value to the Cardano community as a whole in a perennial way.</p> <p>The long-term goal of this project is therefore to collectively build and maintain a testing infrastructure that can benefit the ecosystem and most notably those parties involved in the development and maintenance of the Cardano infrastructure: Nodes, protocols, and related tools. We envision this infrastructure to be governed through an open and transparent process which is yet to be defined by and for the Cardano community through whatever channels seem the most effective.</p> <p>In the short-term however, we need to experiment with the platform, understand what are its capabilities and limits, what it requires from the system-under-test in order to be the most effective, how powerful it is to find and troubleshoot bugs and security vulnerabilities, and more generally openly and candidly build a strong case for the governing bodies of the Cardano ecosystem to decide whether or not this investment shall be pursued.</p> <p>The phases and coarse-grained timeline of the project are documented in the README, and this blog post marks the beginning of the Proof-of-Concept period during which will collaborate with Antithesis to assess the tool.</p>"},{"location":"blog/2025-04-02-kick-off-antithesis/#why-should-you-care","title":"Why should you care?","text":"<p>As already stated, the goal of this project is to evaluate whether the Cardano community, as a whole, could benefit from the continuous availability of Antithesis as a testing infrastructure. This means that if you have some expertise on Cardano, its components, the network, the protocol, and if you have ideas on properties we should be testing, scenarios we should investigate, faults and adversarial behaviours we should be prepared to face, we would be more than happy to hear from you!</p> <p>Concretely, this means that we expect from you as a Cardano enthusiast to help us with:</p> <ul> <li>Improving infrastructure code (eg. docker images, containers, compose files) we use to run tests, and defining particular setups to test,</li> <li>Defining and designing test that explore \"interesting\" scenarios,</li> <li>Stating and refining properties that need to hold, in specific or generic cases,</li> <li>Documenting the expected behaviour in such a way that can easily lead to test generations, for example under the umbrella of the Cardano Blueprint project,</li> <li>Troubleshooting bugs and security vulnerabilities, following our Security policy,</li> <li>...</li> </ul>"},{"location":"blog/2025-05-01-poc-results/","title":"Antithesis Proof-of-Concept Results","text":"<p>Since the start of our project, Cardano Foundation and Antithesis have been busy working on a Proof-of-Concept aimed at evaluating Antithesis's capability to enhance Cardano's testing infrastructure. The results have been promising, with the platform successfully identifying both previously known and new unknown bugs in the cardano-node.</p> <p>This blog post outlines our journey and findings so far, and sketches out plans for the short and medium term in order to ensure this project delivers the most value for the Cardano community.</p>"},{"location":"blog/2025-05-01-poc-results/#overview","title":"Overview","text":"<p>Our exploration with Antithesis began in January 2025, when we first made contact with their team. Quite excited with the prospect this tool offered for testing existing and feature core components of the Cardano network, a small team was assembled within the Cardano Foundation to work on a Proof-of-Concept with Antithesis team. This project was kicked-off on April 2nd at which point both teams started to collaborate actively to understand how to best use the platform to test cardano-node.</p>"},{"location":"blog/2025-05-01-poc-results/#goals-and-objectives","title":"Goals and Objectives","text":"<p>The PoC was undertaken with the main goal of determining if Antithesis could significantly improve our ability to test the Cardano network and its components. As a stretch goal, we also wanted to gauge interest from the broader Cardano community in using such a tool.</p> <p>To achieve these goals, we established several concrete objectives: - Learn how to run Antithesis (AT) on a cluster of cardano-node - Reproduce already known bugs, aka. Brown M&amp;Ms - Discover new, unknown bugs - Engage with the Core team to gather early feedback and build Cardano specific test environment (properties, test composer...) - Outline how Antithesis can benefit the community in the future</p>"},{"location":"blog/2025-05-01-poc-results/#the-teams","title":"The Teams","text":"<p>This initiative brought together expertise from both organizations:</p> <ul> <li>On the Cardano side, people from the HAL, Network and Infrastructure team at the Cardano Foundation, as well as involvement of engineers from IOE's Consensus team</li> <li>On the Antithesis side, solution engineers to support the team.</li> </ul>"},{"location":"blog/2025-05-01-poc-results/#results-and-achievements","title":"Results and Achievements","text":"<p>When measured against our initial objectives, the PoC delivered significantly positive results. Some objectives were not fully completed but they mostly relate to our stated stretch goal. Most importantly, the main goal of this Proof-of-Concept period, namely to demonstrate Antithesis' capabilities to find issues in Cardano network was achieved.</p> <ul> <li> Learn how to run tests with Haskell node: Successfully achieved</li> <li> Reproduce already known bugs: Successfully achieved</li> <li> Find new and unknown bugs: Successfully achieved</li> <li> Engage with other teams to gather early feedback: Partially achieved</li> <li> Learn how to best use AT platform for Cardano: Partially achieved</li> <li> Engage with community to ensure interest and funding: Not achieved</li> </ul>"},{"location":"blog/2025-05-01-poc-results/#more-details-about-our-findings","title":"More details about our findings","text":""},{"location":"blog/2025-05-01-poc-results/#infrastructure","title":"Infrastructure","text":"<p>Using Antithesis to test cardano-node required some initial effort to create the necessary basic infrastructure of Docker images and compose descriptors. As our first objective was to be able to reproduce some peer-to-peer network related bugs, we leveraged and open-sourced our in-house tool for generating testnets configuration.</p> <p>This enabled us to test relatively large clusters of up to 12 nodes while simulating extended time periods of several hours, enough to trigger various changes in the P2P controller. Throughout this process, we had to overcome various minor challenges integrating cardano-node in Antithesis, and it took us a couple of weeks to be able to run a meaningful test to completion.</p> <p>As examplified by the example_10.2.1 directory, the configuration needed to run a cluster of Cardano nodes in AT will be defined as a docker compose file containing:</p> <ul> <li>A set of n networked nodes pulled either from a public or dedicated repository. Each of those containers is typically built from either pre-built cardano-node binaries or a specific source tree, and runs a node along with a process that injects transaction at a regular interval,</li> <li>A sidecar container whose purpose is to monitor the rest of the cluster and notify the AT runner of the main events of interest, most importantly when the cluster is ready to be tested.</li> </ul> <p>An AT run then \"simply\" consists in feeding the <code>docker-compose.yaml</code> file to the API and waiting for the result to be notified.</p>"},{"location":"blog/2025-05-01-poc-results/#bug-discovery","title":"Bug Discovery","text":"<p>Obviously, the purpose of AT is to find bugs and this was our main objective of the proof-of-concept project. Our experiments with AT were able to:</p> <ul> <li>Find three known bugs we reintroduced or left in the nodes voluntarily,</li> <li>Find three unknown bugs, which is the most interesting outcome we could have expected.</li> </ul> <p>The three known bugs were:</p> <ul> <li>Race in the Inbound governor startup logic, an old bug that was discovered with IOSimPOR and fixed in later versions of cardano-node,</li> <li>Peer-sharing known bug which is trivial to trigger,</li> <li>Blockfetch protocol bug which was reinserted during work on new features.</li> </ul> <p>Of the three previously unknown bugs, two are related to networking and one to consensus. The latter was notified to the consensus core team which quickly confirmed the issue and was able to reproduce it locally, leading to patch included in the 10.4.1 version of the node.</p> <p>Some assumptions made by AT can lead it to report bugs which aren't ones, like the fact the cardano-node outputs some metrics at a severity level classified as <code>Critical</code> which AT wrongly interprets as bugs.</p>"},{"location":"blog/2025-05-01-poc-results/#troubleshooting-bug-findings","title":"Troubleshooting bug findings","text":"<p>It's great to find bugs but once one is found, it's even better to be able to investigate promptly its origin. AT provides a few tools to do so, but we haven't had the time yet to leverage those to their fullest extant.</p> <p>Being a deterministic simulation testing platform, AT can explore various \"multiverses\", travelling to the past and trying different configurations and fault injections, to better understand how easily a bug is triggered and what kind of circumstances lead to it. The following picture is an example Bug likelihood graph that is generated from the history of executions</p> <p></p> <p>But the most powerful tool at our disposal is the so-called Multiverse Debugger which provides an environment, similar to Notebook, where one can interact with the System-Under-Test using any tool available in the Docker images and more importantly where it's possible to travel back in time and branch execution of the SUT in order to investigate various hypothesis on the origin of a bug.</p> <p>We tried to investigate one bug through the Multiverse Debugger by using tcpdump to generate pcap files and troubleshoot networking issues, but we were not able to reproduce the bug once observed with tcpdump. However, having the containers fully under our control allowed us to be able to download the node's database which was quite helpful to reproduce issues locally.</p>"},{"location":"blog/2025-05-01-poc-results/#community-engagement","title":"Community Engagement","text":"<p>Community outreach during the PoC period remained an area with significant room for development. We introduced and discussed the platform at the Node Diversity workshop, which sparked some interest among attendees, but as we hadn't had concrete results at the time, this interest did not lead to concrete collaboration. However, the fact we were able to find a genuinely new bug, and the collaboration this lead to with the consensus team, are significantly positive signals that Antithesis can become a valuable asset in the development process of both existing and future \"nodes\".</p> <p>We haven't yet had the opportunity to test Amaru on the Antithesis platform due to lack of time and Amaru state of development which, so far, would not make it possible to run meaningful end-to-end tests in a cluster.</p>"},{"location":"blog/2025-05-01-poc-results/#conclusion","title":"Conclusion","text":"<p>This proof-of-concept project achieved its goals in demonstrating the ability of Antithesis to find interesting bugs, supplementing the existing extensive testing infrastructure the cardano-node possesses. There's still a lot of work lying ahead of us and the Cardano Foundation is committed to keep working with Antithesis to reach that ambitious goal, namely open access to these sophisticated testing capabilities for other node implementations, and more generally the whole Cardano community.</p>"},{"location":"blog/2025-05-01-poc-results/#next-steps","title":"Next steps","text":"<p>To this end, we plan to work along the following axes:</p> <ol> <li>Make it easier for node implementors to use Antithesis for testing,</li> <li>Provide generic properties that can easily be integrated in test composer sidecar that any validator node should respect, such as the one outlined on the Ouroboros Consensus page and drawn from the research papers.</li> </ol> <p>More concretely, in the short term we'll be focusing on:</p> <ol> <li>Better documentation on how to run new tests on the platform,</li> <li>Automating test executions and report sharing through GitHub actions,</li> <li>Enable logs based SDK using cardano-tracer to aggregate cardano-node logs,</li> <li>Express more interesting properties (Chain prefix, chain density, chain growth...) as composable scripts or executables to be included in test composer images,</li> <li>Collaborate with cardano-node, Amaru, and other node implementor teams interested in leveraging Antithesis.</li> </ol> <p>We also want to contribute useful tools and techniques, that can be used both within and without the Antithesis platform, as has been discussed in the Node Diversity Workshop that took place in Paris a month ago:</p> <ol> <li>Generalise the block tree generators and other testing tools already existing in ouroboros-consensus to make them usable with arbitrary node implementations,</li> <li>Implement an adversarial node that would actively try to thwart honest nodes.</li> </ol>"},{"location":"blog/2025-05-01-poc-results/#call-to-action","title":"Call To Action","text":"<p>Because we believe the safety and security of the network is the responsibility of the whole community, this project is meant to be as open as possible and we actively seek and encourage contributions which could take a wide variety of forms:</p> <ul> <li>Improve infrastructure code (eg. docker images, containers, compose files) we use to run tests,</li> <li>Better document this infrastructure and how to run those tests,</li> <li>Define tests that explore \"interesting\" scenarios,</li> <li>...</li> </ul>"},{"location":"blog/2025-09-08-some-news/","title":"Antithesis tools for Cardano Community","text":"<p>The next Node diversity workshop, where Cardano developers focusing on building various kind of nodes will meet in Toulouse, is just around the corner. It therefore seemed a good idea to share an update on the Antithesis project initiated by the Cardano Foundation, especially as representatives from Antithesis and the teams working on this project will attend the workshop!</p> <p>And although it's been while since we have shared news in our latest blog post, the project hasn't stayed still and we made progress on a number of fronts, ready for the next phase namely its transformation from an experiment restricted to a small team to a community-lead resource.</p>"},{"location":"blog/2025-09-08-some-news/#testing-cardano-node-with-antithesis","title":"Testing cardano-node with Antithesis","text":"<p>Since May we have been running Antithesis on a cluster of 5 cardano-nodes as part of the Continuous Integration process of the project, leveraging the existing Github Action to trigger test runs. Those test runs have been done on the latest available versions of the Docker image of cardano-node, on the <code>master</code> branch, and checking a limited number of basic properties on top of the ones provided by Antithesis out-of-the-box:</p> <ul> <li>The main property checked is implemented in the eventually-converged.sh script and, as its name implies, checks that all nodes have reached the same tip eventually. The fact this is an eventually command is critically important as it guarantees it will be run and its status checked at the end of the test run and without any more faults injected. It took us a while to refine the property and work with the Antithesis team to ensure it does not produce false positives,</li> <li>We also check 2 Never properties related to logs emitted by the cardano-node: That it never emits <code>Error</code> or <code>Critical</code> logs.</li> </ul> <p>Note that by default Antithesis checks a number of other properties, like the fact no container exits unexpectedly, or that the processes run never go over 95% of the memory available.</p> <p>The team's effort has not been particularly focused on finding bugs, but we still managed to report a couple of potentially \"interesting\" issues to the core developers: One issue related to DNS resolution failure timeout, and a potential race condition in the shutdown/startup sequence.</p>"},{"location":"blog/2025-09-08-some-news/#tracking-test-runs-on-chain","title":"Tracking test runs on-chain","text":"<p>The main goal of this project has always been to open access to the Antithesis resource to the Cardano community, in a transparent, fair, and as easy as possible way. And what's better than a blockchain like Cardano to manage access to a shared resource transparently? Furthermore, as developers of Cardano systems it seems quite logical and inline with the principle of dogfooding to insist on using Cardano itself in our development workflow.</p> <p>Once convinced about the capabilities of the tool, we started designing and building a Cardano-based system that would allow developers to \"easily\" request test runs for their particular software stack, and receive results and reports once produced by the platform. Version 0.2.0.0 of the command-line tool called anti-cli has just been released and it provides the core features needed to manage the lifecycle of Antithesis tests for any system hosted on Github<sup>1</sup>.</p> <p>Anti-cli leverages Merkle-Patricia Forestry Service as a backend-service to store data off-chain with proofs verifiable on-chain. This service is in turn based on the excellent Aiken Merkle-Patricia Forestry library.</p> <p>The following picture illustrates the overall design of this application and how it interacts with the chain and the Antithesis service:</p> <p></p> <p>The developer, here Alice uses anti-cli to post test run requests and retrieve test run results from the MPFS service. MPFS service is used to compute unsigned transactions necessary for the parties to operate index the blockchain to track and serve the state of the interaction. It can be run locally, giving it access to a node, or parties can use a remote instance (see mpfs repository).</p> <p>On the other side, the Agent is reponsible for mediating and curating run requests, forward those requests to the Antithesis service, retrieve the tests result, and finally notify the results on-chain for Alice's consumption. Note that because of the sensitive nature of test results, the report's URL posted on-chain is encrypted using Alice's public key which in turns require them to record this key as part of their registration process.</p> <p>More details can be found in the anti-cli documentation.</p>"},{"location":"blog/2025-09-08-some-news/#testing-amaru-in-antithesis","title":"Testing Amaru in Antithesis","text":"<p>Amaru is an alternative node implemented in Rust which is being actively developed by a small but dedicated team under the umbrella of PRAGMA, a Member-Based Organisation dedicated exclusively to foster open-source projects. As such it's a prime candidate to prove Antithesis' relevance for the development of core systems in Cardano beside the cardano-node itself.</p> <p>It took the team some time to get there, as there were quite a few moving parts to get right in order to be able to run a cluster of cardano-nodes and amaru nodes<sup>2</sup>, but we finally managed to run our first Antithesis in the past couple of weeks.</p> <p>The setup is pretty simple: We spin up a network of 5 block producing cardano-nodes and 2 Amaru nodes in client mode, with one of the Amarus connected to a cardano-node and the other one to the previous Amaru node. While the test run itself wasn't successful, which is expected given the current state of development of Amaru, this is nevertheless a huge step forward for us.</p> <p>Details of the setup can be found in the Amaru codebase. This initial success paves the way for quickly pinpointing main shortcomings in Amaru and target development effort accordingly first to make sure Amaru can be a reliable relay and then turn into a full-fledged block producer.</p>"},{"location":"blog/2025-09-08-some-news/#adversarial-node-network","title":"Adversarial node &amp; network","text":"<p>A key feature of Antithesis is its ability to inject faults in the System-under-test. Currently, Antithesis can trigger various kind of network-related faults like dropped or delayed packets, disconnections, split-brains ; cpu and memory throttling to simulate sudden limitation of resources ; or random crashes. But as clearly stated in the documentation page, those faults are very generic and simulate faults from the environment but not really adversarial behaviour, and as we are the ones knowing our system best it rests on us to produce more interesting faults.</p> <p>Following initial discussions with the Consensus team we have started work on an Adversarial Node. This is intended to be an extensible and configurable application that can be triggered by Antithesis platform during tests to emulate adversarial behaviour at the protocol and logic level. Our very first \"adversary\" is quite mild in its \"attacks\" on nodes as it merely tries to open several connections to a node and start synchronising the chain from random points in the past. Its goal is to expose potential issues in the way a node tracks Chain followers, eg. memory leaks, concurrency issues, network resources allocation...</p> <p>A key design constraint of the Adversary is that it should only act through Cardano protocols, without any prior knowledge of the implementation of the nodes it connects to. This makes it possible to use the Adversary in any valid Cardano-network and running against any piece of software implementing Cardano protocols, whether at the network, consensus, or even ledger level<sup>3</sup>.</p>"},{"location":"blog/2025-09-08-some-news/#conclusion-future-work","title":"Conclusion &amp; Future work","text":"<p>While the High-Assurance Lab team at Cardano foundation has made great progress to turn what started as an experiment and proof-of-concept a few months ago into a full-fledged usable project, there obviously remains a lot to be done. Our end goal is to build tools and systems that benefit the Cardano ecosystem a as whole by providing easy-to-use, transparent, and safe access to a sophisticated testing tools empowering teams with state-of-the-art system-level testing infrastructure.</p> <p>But we also want these tools and systems to be owned by the community in order to ensure adequate funding and proper governance of something we believe can increase the level of quality, resilience, and therefore confidence in Cardano. That's why we are eager to engage with \"node builders\" around the globe, and to collaborate with all teams and projects building core infrastructure components and applications to make the most out of this effort.</p> <ol> <li> <p>We have tested the tool not only internally within the team, but using Amaru as our guinea pig project.\u00a0\u21a9</p> </li> <li> <p>For more details on this journey, one can consult the team's journal.\u00a0\u21a9</p> </li> <li> <p>We have good hopes this adversary will be useful in other contexts, in particular within the context of Tartarus.\u00a0\u21a9</p> </li> </ol>"},{"location":"dev/code-design/","title":"Code Design Decisions","text":""},{"location":"dev/code-design/#opt-env-conf-vs-optparse-applicative","title":"opt-env-conf vs optparse-applicative","text":"<p>Optparse-applicative is a popular library for parsing command-line options in Haskell. It provides a declarative way to define command-line interfaces and supports features like subcommands, flags, and arguments.</p> <p>Opt-env-conf is a library that extends optparse-applicative by adding support for environment variables and configuration files. It allows developers to define options that can be set via command-line arguments, environment variables, or configuration files, providing more flexibility in how applications can be configured.</p> <p>We chose to use opt-env-conf over optparse-applicative for the following reasons: 1. Some commands require some env vars to be set, while others don't. opt-env-conf allows us to handle this complexity more gracefully, wihout passing around Maybe values. 2. We need to handle both encrypted and unencrypted mnemonics. Depending on that the settings are different. opt-env-conf allows us to define different settings based on the context, making it easier to manage these variations. In particular after parsing the env var MOOG_WALLET_FILE we insert a read-only operation (checkMapIO) that brings in the fields of the wallet file as settings. Depending on the field we require different settings for the passphrase. 3. We want to support interactive prompts for sensitive information like passwords. opt-env-conf <code>mapIO</code> allows us to introduce interactive prompts as part of the settings parsing process, making it easier to handle user input securely.</p>"},{"location":"dev/code-design/#commands-as-gadts","title":"Commands as GADTs","text":"<p>All commands are reified as GADTs where - each constructor represents a command - the fields of the constructor are the arguments of the command - the return type of the constructor is the return type of the command</p> <p>By using GADTs it's possible to have a different output type for each command.</p> <p>To structure the commands we use subcommands. Higher level commands just wraps the lower level ones. For example the <code>moog wallet</code> command is a subcommand of the <code>moog</code> command and the <code>moog wallet create</code> command is a subcommand of the <code>moog wallet</code> command.</p> <p>Thanks to GADTs the high level commands can just demandate the output type of the lower level commands and return it as their own output type.</p>"},{"location":"dev/code-design/#parsing-commands","title":"Parsing commands","text":"<p>The parsing of the commands is done using the <code>opt-env-conf</code> library. See the opt-env-conf documentation for more details.</p> <p>Command parsers for the same GADTs compose via the <code>Alternative</code> typeclass. This means that each command parser can be defined independently and then combined together to form the full command parser.</p> <p>Arguments parsers compose via the <code>Applicative</code> typeclass. This means that each argument parser can be defined independently and then combined together to form the full command parser for a command.</p>"},{"location":"dev/code-design/#existential-boxing-of-the-command-results","title":"Existential boxing of the command results","text":"<p>Because each command can have a different return type, we need to box the result of the command in an existential type. This is done using the <code>Box</code> type. The <code>Box</code> allows only for results that can be rendered as canonical JSON.</p> <p><code>Box</code> has a form of fmapping called <code>fmapBox</code> that allows to transform the inner value of the box while keeping the box type. This is useful when creating options for high level commands that just wrap lower level commands.</p>"},{"location":"ops/agent-role/","title":"Agent role manual","text":""},{"location":"ops/agent-role/#agent-service-architecture","title":"Agent Service Architecture","text":"<pre><code>flowchart TB\n    subgraph Agent Automation Loop\n        poll[Poll for pending test runs]\n        check[Check pending requests]\n        download[Download test assets from GitHub]\n        validate[Local docker compose validation]\n        push[Push to Antithesis platform]\n        accept[Report acceptance on-chain]\n        email[Check email for results]\n        report[Report completion on-chain]\n    end\n\n    poll --&gt; check --&gt; download --&gt; validate --&gt; push --&gt; accept\n    poll --&gt; email --&gt; report\n\n    MPFS[(MPFS)] &lt;--&gt; poll\n    GH[GitHub] --&gt; download\n    AT[Antithesis] &lt;--&gt; push\n    MPFS &lt;--&gt; accept\n    MPFS &lt;--&gt; report</code></pre>"},{"location":"ops/agent-role/#running-as-docker-service","title":"Running as Docker Service","text":"<p>The agent can run as an automated Docker service that continuously polls for and processes test runs.</p> <p>See the Deployment Guide for full setup instructions including secrets, docker-compose configuration, and startup.</p>"},{"location":"ops/agent-role/#automation-flags","title":"Automation flags","text":"Flag Description Default <code>--poll-interval</code> Seconds between polling cycles 60 <code>--minutes</code> Time window (in minutes) to search for email results \u2014 <code>--trust-all-requesters</code> Accept test runs from any requester (skip trusted list check) disabled <p>Deprecated flag</p> <p>The <code>--days</code> flag was replaced by <code>--minutes</code> in v0.4.1.1. Use <code>--minutes 1440</code> instead of <code>--days 1</code>.</p>"},{"location":"ops/agent-role/#environment-variables","title":"Environment variables","text":"Variable Description <code>MOOG_MPFS_HOST</code> URL of the MPFS service <code>MOOG_WALLET_FILE</code> Path to the agent wallet JSON file <code>MOOG_TOKEN_ID</code> The moog token asset ID <code>MOOG_SECRETS_FILE</code> Path to <code>secrets.yaml</code> <code>MOOG_WAIT</code> Seconds between polling cycles (alternative to <code>--poll-interval</code>) <code>MOOG_ANTITHESIS_USER</code> Antithesis platform username <code>DOCKER_CONFIG</code> Path to Docker config directory (for private registries)"},{"location":"ops/agent-role/#docker-socket-and-privileged-mode","title":"Docker socket and privileged mode","text":"<p>The agent container requires:</p> <ul> <li>Docker socket (<code>/var/run/docker.sock</code>) \u2014 the agent runs <code>docker compose up --build</code> to validate test assets locally before pushing them to Antithesis.</li> <li>Privileged mode \u2014 required for Docker-in-Docker operations.</li> </ul> <p>See Security for the security implications of this setup.</p>"},{"location":"ops/agent-role/#white-list-repositories","title":"White-list repositories","text":"<p>In the interest of avoiding spam the agent has to white-list repositories before the oracle will accept test-runs for them.</p> <p>Two commands are available</p>"},{"location":"ops/agent-role/#white-list-a-repository","title":"White-list a repository","text":"<p>This will only work if the repository is not already white-listed and the repository is in GitHub. <pre><code>moog agent white-list &lt;platform&gt; &lt;repository&gt;\n</code></pre></p> <p>ATM only GitHub is supported as a platform. The format of the repository is <code>&lt;owner&gt;/&lt;repository&gt;</code>, e.g. <code>cardano-foundation/moog</code>.</p>"},{"location":"ops/agent-role/#black-list-a-repository","title":"Black-list a repository","text":"<p>This will only work if the repository is white-listed. <pre><code>moog agent black-list &lt;platform&gt; &lt;repository&gt;\n</code></pre></p>"},{"location":"ops/agent-role/#query-pending-test-runs","title":"Query pending test-runs","text":"<p>The agent is responsible for managing test-runs from pending to running and completed.</p> <p><pre><code>moog facts test-runs pending --pretty\n</code></pre> will report all the pending test runs in a human friendly format.</p>"},{"location":"ops/agent-role/#download-a-test-run-assets","title":"Download a test-run assets","text":"<p>Once a test-run is pending the agent can download the assets for the test-run.</p> <pre><code>moog agent download-assets -i &lt;test-run-id&gt; -D &lt;directory&gt;\n</code></pre> <p>This will download the assets for the test-run with id <code>&lt;test-run-id&gt;</code> into the directory <code>&lt;directory&gt;</code>.</p>"},{"location":"ops/agent-role/#start-a-test-run-locally","title":"Start a test-run locally","text":"<p>At the moment there is no moog-cli command to start a test-run locally. But a minimal check could be done via docker compose.</p> <pre><code>cd &lt;directory&gt;\nINTERNAL_NETWORK=true docker compose up --build\n</code></pre> <p>Obviously you should do all kind of analysis you deem necessary on the assets before deciding the next step.</p>"},{"location":"ops/agent-role/#reject-a-test-run","title":"Reject a test-run","text":"<p>If the agent decides a test-run is not acceptable it can reject it.</p> <pre><code>moog agent reject-test -i &lt;test-run-id&gt; --reason &lt;reason&gt;\n</code></pre>"},{"location":"ops/agent-role/#push-a-test-run-to-antithesis-platform","title":"Push a test-run to antithesis platform","text":"<p>Once decided a test-run is acceptable the agent can push the test-run to the antithesis platform.</p> <pre><code>moog agent push-test -i &lt;test-run-id&gt; -D &lt;directory&gt;\n</code></pre> <p>This will push the test-run with id <code>&lt;test-run-id&gt;</code> to the antithesis platform</p>"},{"location":"ops/agent-role/#report-the-acceptance-of-a-test-run-on-chain","title":"Report the acceptance of a test-run on-chain","text":"<p>Once a test-run is pushed to the antithesis platform the agent has to report the acceptance of the test-run on-chain.</p> <pre><code>moog agent accept-test -i &lt;test-run-id&gt;\n</code></pre> <p>This will move it from <code>pending</code> to <code>running</code> state in the facts.</p>"},{"location":"ops/agent-role/#check-for-the-completion-of-a-test-run","title":"Check for the completion of a test-run","text":"<p>ATM we can only collect results via email. The email is passed in the post request when the test-run on the recipients list.</p> <pre><code>export MOOG_AGENT_EMAIL=\"&lt;your-email&gt;\"\n</code></pre> <p>Then you can check for the completion of a test-run via</p> <pre><code>moog agent collect-results-for --test-run-id &lt;test-run-id&gt; --minutes &lt;n&gt; --ask-agent-email-password\n</code></pre> <p>HAL Team</p> <p>To use your CF email you have to use an app password. If you use your password you  will get an error like</p> <p><code>LoginFailed user error (NO: Application-specific password required: https://support.google.com/accounts/answer/185833 (Failure))</code></p> <p>Just go to https://myaccount.google.com/apppasswords and create an app password.</p>"},{"location":"ops/agent-role/#report-the-completion-of-a-test-run-on-chain","title":"Report the completion of a test-run on-chain","text":"<p>Once the result URL is retrieved the agent has to report the completion of the test-run on-chain.</p> <pre><code>moog agent report-test -i &lt;test-run-id&gt; --url &lt;result-url&gt;  --duration &lt;duration-in-hours&gt;\n</code></pre> <p>The URL is encrypted automatically with the requester's public key.</p>"},{"location":"ops/architecture/","title":"Architecture Overview","text":"<p>This document provides an overview of the architecture of the Antithesis CLI tool, which is designed to administer Antithesis tests execution through Cardano.</p>"},{"location":"ops/architecture/#decentralization-model","title":"Decentralization model","text":"<p>The Antithesis CLI tool operates within a decentralized framework, leveraging blockchain technology to ensure transparency, security, and immutability of test execution records.</p> <p>First-class participation would imply access to a Cardano node. However, the system is designed to separate blockchain interaction from test execution management, allowing the backend service to run separately, next to the Cardano node.</p> <p>To improve component reusability, the backend service has no knowledge of project-specific goals and is developed in a separate repository: MPFS.</p> <p>In a perfect setup, each actor should run both the CLI tool and the MPFS service locally. However, for practical reasons, we expect most users to run only the CLI tool while relying on remote shared instances of the MPFS service. Security considerations should be taken into account when choosing between local or shared MPFS service instances.</p>"},{"location":"ops/architecture/#systems","title":"Systems","text":"<pre><code>architecture-beta\n    service gh(cloud)[GitHub]\n    service antithesis(cloud)[Antithesis]\n    service chain(internet)[Cardano Blockchain preprod]\n    group cf(cloud)[Cardano foundation Antithesis tenant]\n        service agent(server)[Agent process] in cf\n        service oracle(server)[Oracle process] in cf\n        service cfMpfs(server)[MPFS Service] in cf\n    agent:R -- L:cfMpfs\n    oracle:L -- R:cfMpfs\n    agent:B -- T:antithesis\n    oracle:B -- T:gh\n    cfMpfs:T -- L:chain\n    group nodeDevs(cloud)[Cardano node devs]\n        junction nodej in nodeDevs\n        service alice(server)[Alice console] in nodeDevs\n        service bob(server)[Bob console] in nodeDevs\n        service nodeDevsMpfs(server)[Team MPFS Service] in nodeDevs\n        service mpfsAlice(server)[Alice MPFS Service] in nodeDevs\n    bob:L -- R:nodeDevsMpfs\n    nodeDevsMpfs:B -- T:nodej\n    mpfsAlice:T -- B:nodej\n    nodej:L -- R:chain\n    alice:L -- R:mpfsAlice\n    service publicMpfsHost(cloud)[Public MPFS Service]\n    publicMpfsHost:B -- T:chain\n    group hydraDevs(cloud)[Hydra devs]\n        junction hydraj in hydraDevs\n        service john(server)[John console] in hydraDevs\n        service mary(server)[Mary console] in hydraDevs\n    john:T -- B:hydraj\n    mary:B -- T:hydraj\n    hydraj: R -- L:publicMpfsHost\n    group  dingoDevs(cloud)[Dingo devs]\n        service charlie(server)[Charlie console] in dingoDevs\n        service dave(server)[Dave console] in dingoDevs\n    charlie:B -- T:publicMpfsHost\n    dave:B -- T:nodeDevsMpfs</code></pre>"},{"location":"ops/architecture/#github-platform","title":"GitHub Platform","text":"<p>We use GitHub services to manage user identities, roles, and per-repository test assets hosting.</p> <pre><code>graph TD\n        A[GitHub Platform] --&gt;|identifies a user via| B[a moog.vkey file in personal repo]\n        A --&gt;|certifies a tester role in a repository via| C[a CODEOWNERS record in repository]\n        A --&gt;|provides test definitions via| D[files in a directory of a registered repository]</code></pre>"},{"location":"ops/architecture/#github-as-identity-provider","title":"GitHub as identity provider","text":"<p>Any GitHub user can register themselves against the system state by deploying a file containing a Cardano public key in their personal GitHub repository. - GitHub docs: profile repository. - Example: moog.vkey.</p>"},{"location":"ops/architecture/#github-as-antithesis-role-management","title":"Github as Antithesis role management","text":"<p>To grant the Antithesis tester role, a GitHub repository must explicitly list GitHub users in its CODEOWNERS file; the system uses this mapping to determine which users are authorized as testers for that repository. - Example: CODEOWNERS</p>"},{"location":"ops/architecture/#github-as-test-assets-hosting","title":"Github as test assets hosting","text":"<p>Any GitHub repository that has been registered with the system (i.e., contains a valid user public key and is whitelisted for test execution) can host a directory containing test definitions that meet the required format and standards. Currently only a runnable docker-compose.yaml is required.</p> <ul> <li>Example: test definition</li> </ul>"},{"location":"ops/architecture/#antithesis-platform","title":"Antithesis Platform","text":"<p><pre><code>graph TD\n        A[Antithesis Platform] --&gt;|runs tests via| B[Antithesis API]\n        A --&gt;|provides test results via| C[email with test results]</code></pre> Antithesis is the test execution platform that provides the infrastructure to run tests and collect results. Currently we use a POST API to create test runs and fetch results via email parsing. In the future the platform will provide a better API to manage test runs and fetch results.</p> <ul> <li>Antithesis docs: API</li> </ul>"},{"location":"ops/architecture/#cardano-blockchain","title":"Cardano Blockchain","text":"<pre><code>graph TD\n        A[Cardano Blockchain] --&gt;|certifies the moog state via| B[an unspent MPFS state token UTxO]\n        A --&gt;|stores moog state| C[some spent MPFS request UTxOs]\n        A --&gt;|provides moog state content security | D[the MPFS smart contract]</code></pre> <p>The blockchain will store data and certifications for - GitHub user and their associated Cardano public keys. - GitHub roles such as repository testers by Antithesis. - Repository whitelisting for test execution. - Oracle validation configuration. - Record of each test execution requests and (link to their) results.</p> <p>The cryptographic aspects of the system are defined by the use of an underlying MPFS system as intermediary between the CLI tool and the blockchain.</p> <p>This choice enforce a strict protocol that ensures</p> <ul> <li>Any system fact is always certified on-chain (merkle root).</li> <li>All and only of the system state transitions have been recorded in the merkle tree have been spent and validated on-chain.</li> </ul>"},{"location":"ops/architecture/#mpfs-service-instances","title":"MPFS Service instances.","text":"<pre><code>graph TD\n        A[MPFS Service] --&gt;|provides moog state via| B[GET /facts]\n        A --&gt;|produces unsigned transactions via| C[POST /transaction/&lt;addr&gt;/txtype]\n        A --&gt;|submits signed transactions via| D[POST /transaction]</code></pre> <p>The MPFS Service is a backend system that all actors will use to interact with the blockchain in a way independent from the application logic.</p> <p>It exposes a REST API to be used by the CLI tool.</p> <p>The system is capable of producing unsigned transactions for the system users, submitting signed transactions to the blockchain, and most importantly providing the current system state, cryptographically certified and stored on-chain.</p> <p>We borrow many concepts and much terminology from the MPFS project. In particular the system state is referred to as facts.</p>"},{"location":"ops/architecture/#moog-cli-tool-and-automations","title":"Moog CLI Tool (and automations)","text":"<p><pre><code>graph TD\n        A[Moog CLI Tool] --&gt;|interacts with| B[MPFS Service]\n        A --&gt;|interacts with| C[GitHub Platform]\n        A --&gt;|interacts with| D[Antithesis API]\n        A --&gt;|serves as| E[Requester role]\n        A --&gt;|serves as| F[Agent role]\n        A --&gt;|serves as| G[Oracle role]</code></pre> This is the command line interface that users will use to interact with the MPFS service and GitHub and manage their test executions on Antithesis. With it users can: - Browse the system state querying the MPFS service for facts (as any role). - Issue and validate requests to update the system state via Cardano transactions (as requester or agent). - Interact with GitHub to validate requests against the system state (as requester or agent). - Interact with Antithesis API to create test runs and collect results (as agent).</p>"},{"location":"ops/architecture/#roles","title":"Roles","text":"<p>The CLI tool, along with its built-in automation features for test execution and state management, supports the following roles: requester, agent, and oracle.</p>"},{"location":"ops/architecture/#requester-role","title":"Requester role","text":"<pre><code>graph LR\n        A[Requester role] --&gt;|register as Github user via| UR[*]\n        UR --&gt;|deployment of| B[a moog.vkey file in personal repo]\n        UR --&gt;|submission of| C[a register-user request to MPFS service]\n        A --&gt;|register as tester for a repo via| RR[*]\n        RR --&gt;|deployment of| D[a CODEOWNERS record in the repository]\n        RR --&gt;|submission of| E[a register-role request to MPFS service]\n        A --&gt;|create test runs via| TR[*]\n        TR --&gt;|deployment of| F[test definition files in a registered repository]\n        TR --&gt;|submission of| G[a create-test request to MPFS service]</code></pre> <p>A GitHub user who initiates test execution requests on the Antithesis platform.</p> <p>The <code>requester</code> role involves no automation; users interact exclusively through the CLI tool to act as a requester.</p> <p>They use the CLI tool to submit administrative requests (such as user and role registration) and test requests (such as creating test runs), interacting with the MPFS service and GitHub to validate their actions against the current system state.</p> <p>The <code>requester</code> role is fully manual, requiring users to perform all actions through the CLI tool without automation.</p>"},{"location":"ops/architecture/#agent-role","title":"Agent role","text":"<pre><code>graph LR\n        A[Agent role] --&gt;|accept test execution requests via| TR[*]\n        TR --&gt;|submission of| B[a create-test request to MPFS service]\n        TR --&gt;|POST to| C[Antithesis API]\n        A --&gt;|collect test results via| RR[*]\n        RR --&gt;|email parsing from| D[email with test results]\n        RR --&gt;|submission of| E[a report-test request to MPFS service]\n</code></pre> <p>A user who interacts with both the Antithesis API and the MPFS service, responsible for automating the execution of tests on the Antithesis platform and collecting results, while also managing relevant state changes and validations.</p> <p>The <code>agent</code> role is partially automated and so an executable and docker image is provided to run it as a service; however, the agent must manually <code>whitelist</code> repositories using the CLI tool before the oracle can validate test execution requests from those repositories.</p>"},{"location":"ops/architecture/#oracle-role","title":"Oracle role","text":"<p><pre><code>graph LR\n        A[Oracle role] --&gt;|include requests via| TR[*]\n        TR --&gt;|validation| I[against with GitHub Platform]\n        TR --&gt;|validation| J[of transaction signatures]\n        TR --&gt;|validation| K[of moog state consistency]\n        TR --&gt;|submission of| B[a state update transaction to MPFS service]</code></pre> A trusted user that manages and maintains authority over the system state, validates requests from the other roles, and updates the state of the system on the blockchain. The <code>oracle</code> role is fully automated; an executable and Docker image are provided to run it as a service.</p>"},{"location":"ops/architecture/#mpfs-derived-concepts","title":"MPFS derived concepts","text":"<p>The use of MPFS imposes a strict protocol and terminology to describe the interactions between the different roles.</p>"},{"location":"ops/architecture/#state-token","title":"State token","text":"<pre><code>graph LR\n    A[State token] --&gt;|holds the system state as| B[merkle root in UTxO datum]\n    A --&gt;|is caged into| C[the MPFS script address]\n    A --&gt;|holds the oracle identity as| D[oracle public key in UTxO datum]\n    A --&gt;|is updateable by| F[the oracle role only]</code></pre> <p>The MPFS is a multi-project token centric system, meaning that each project's state and identity are managed through unique tokens on the Cardano blockchain.</p> <p>Each project is represented by a unique asset, but they all share the same MPFS policy id. The policy id imposes a minting policy that ensures the merkle tree is empty at the beginning of time and that the asset is unique on the blockchain.</p> <p>The MPFS policy id is also the script address where each project token is caged into. The script is responsible for enforcing the MPFS protocol on all MPFS tokens.</p> <p>Each state token holds the system state as a <code>merkle root</code> in a UTxO datum. The smart contract script enforces that any state transition must consume the current state token and produce a new state token with an updated merkle root and put it back at the same script address.</p> <p>Only the <code>oracle</code> role is allowed to update (consume) the state token and put back a new version of it with an updated state.</p>"},{"location":"ops/architecture/#state-change-requests","title":"State change requests","text":"<p><pre><code>graph LR\n    A[State change request] --&gt;|proposes changes to the system state as| B[deltas in UTxO datum]\n    A --&gt;|targets a specific project via| C[project token asset id in UTxO datum]\n    A --&gt;|is created by| D[requester or agent roles]\n    A --&gt;|is consumed by| E[the oracle role only]</code></pre> <code>requester</code> and <code>agent</code> roles are both seen as users from the MPFS perspective. They interact with the system by issuing state change requests.</p> <p>State change requests appears on chain as UTxO datums locked at the MPFS script address. They contain proposed changes in the form of deltas to be applied to the current system state. They also contain the asset id of the project token they are targeting.</p> <p>The smart contract script enforces that they are only consumed by the <code>oracle</code> role when updating the system state.</p> <p>A broad classification of change requests for our project is: - Requester role:   - Administrative requests: used to register users and roles (a.k.a. repositories)   - Test requests: used to create test runs - Agent role:   - Administrative requests: used to whitelist repositories   - Test requests: used to accept/reject test runs and update test results - Oracle role:   - The oracle role exceptionally behave as a user when it publishes its own configuration on-chain.</p>"},{"location":"ops/architecture/#state-updates","title":"State updates","text":"<p>The <code>oracle</code> role as seen from the MPFS perspective is the guardian of the system state.</p> <p>As an MPFS oracle it is responsible for - Creating the project token in the MPFS - Updating the token state based on the change requests issued by the other roles.</p> <p>As the guardian of the state it has the responsibility to validate the change requests and prevent inconsistent data to enter/exit the token. Typical validations on requests performed by the oracle are: - Validating GitHub credentials and roles. This is really post-oracle-ing GitHub. - Validating digital signatures on requests. Only registered users are allowed to start new tests. - Validating repository whitelisting for test execution. Only tests for whitelisted repositories are allowed. - Validating the identity of the <code>agent</code> role when it comes to modify the tests state. - Validating the test parameters (e.g. platform, repository, commit, etc.) at test creation time. - Validating the tests state transitions respect semantic consistency. Every test state is modelled as a finite state machine and the oracle ensures that only valid transitions are allowed.</p>"},{"location":"ops/deployment/","title":"Deployment Guide","text":"<p>This guide covers deploying the oracle and agent services as Docker containers.</p>"},{"location":"ops/deployment/#infrastructure-overview","title":"Infrastructure Overview","text":"<pre><code>graph TB\n    subgraph Oracle Machine\n        oracle[moog-oracle container]\n        oracle-secrets[secrets.yaml&lt;br/&gt;oracle-wallet.json]\n    end\n    subgraph Agent Machine\n        agent[moog-agent container]\n        agent-secrets[secrets.yaml&lt;br/&gt;agent-wallet.json&lt;br/&gt;docker/config.json]\n        docker[Docker socket]\n    end\n    subgraph External Services\n        mpfs[MPFS Service]\n        cardano[Cardano Blockchain&lt;br/&gt;preprod]\n        github[GitHub API]\n        antithesis[Antithesis Platform]\n    end\n\n    oracle --&gt; mpfs\n    oracle --&gt; github\n    agent --&gt; mpfs\n    agent --&gt; antithesis\n    agent --&gt; docker\n    mpfs --&gt; cardano\n    oracle-secrets -.-&gt; oracle\n    agent-secrets -.-&gt; agent</code></pre>"},{"location":"ops/deployment/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker and Docker Compose on each machine</li> <li>Cardano wallets for both oracle and agent roles (created with <code>moog wallet create</code>)</li> <li>GitHub PAT with <code>repo</code> scope for the oracle (used to validate requests against GitHub)</li> <li>GitHub PAT with <code>repo</code> scope for the agent (used to download test assets)</li> <li>Antithesis credentials for the agent (registry password, platform user)</li> <li>MPFS service accessible from both machines (default: <code>https://mpfs.plutimus.com</code>)</li> <li>Moog token already created by the oracle (<code>moog oracle token boot</code>)</li> </ul>"},{"location":"ops/deployment/#oracle-deployment","title":"Oracle Deployment","text":""},{"location":"ops/deployment/#secrets-setup","title":"Secrets setup","text":"<p>Create the secrets directory:</p> <pre><code>mkdir -p /secrets/moog-oracle\n</code></pre> <p><code>/secrets/moog-oracle/oracle.json</code> \u2014 the oracle wallet file (from <code>moog wallet create</code>).</p> <p><code>/secrets/moog-oracle/secrets.yaml</code>:</p> <pre><code>githubPAT: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nwalletPassphrase: your_wallet_passphrase  # if wallet is encrypted\n</code></pre>"},{"location":"ops/deployment/#docker-compose","title":"Docker Compose","text":"<p>Use the compose file from <code>CD/moog-oracle/docker-compose.yaml</code>:</p> <pre><code>services:\n  moog-oracle:\n    image: ghcr.io/cardano-foundation/moog/moog-oracle:${MOOG_VERSION:-latest}\n    secrets:\n      - oracle-wallet\n      - secrets\n    environment:\n      - MOOG_MPFS_HOST=https://mpfs.plutimus.com\n      - MOOG_WALLET_FILE=/run/secrets/oracle-wallet\n      - MOOG_TOKEN_ID=&lt;your-token-id&gt;\n      - MOOG_SECRETS_FILE=/run/secrets/secrets\n      - MOOG_WAIT=240\n    restart: always\n    volumes:\n      - tmp:/tmp\nsecrets:\n  oracle-wallet:\n    file: /secrets/moog-oracle/oracle.json\n  secrets:\n    file: /secrets/moog-oracle/secrets.yaml\nvolumes:\n  tmp:\n</code></pre>"},{"location":"ops/deployment/#start-and-verify","title":"Start and verify","text":"<pre><code>export MOOG_VERSION=&lt;desired-version&gt;\ndocker compose up -d\ndocker compose logs -f moog-oracle\n</code></pre> <p>Look for log lines showing successful polling and validation cycles. The oracle polls every <code>MOOG_WAIT</code> seconds (default 240).</p>"},{"location":"ops/deployment/#agent-deployment","title":"Agent Deployment","text":""},{"location":"ops/deployment/#secrets-setup_1","title":"Secrets setup","text":"<p>Create the secrets directory:</p> <pre><code>mkdir -p /secrets/moog-agent/docker\n</code></pre> <p><code>/secrets/moog-agent/agent.json</code> \u2014 the agent wallet file.</p> <p><code>/secrets/moog-agent/docker/config.json</code> \u2014 Docker registry credentials for pulling/pushing Antithesis images.</p> <p><code>/secrets/moog-agent/secrets.yaml</code>:</p> <pre><code>agentEmail: agent@example.com\nagentEmailPassword: xxxx-xxxx-xxxx-xxxx  # Google app password\ngithubPAT: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nantithesisPassword: your_antithesis_password\nslackWebhook: https://hooks.slack.com/services/...  # optional\ntrustedRequesters:  # optional, ignored when --trust-all-requesters is used\n  - requester_pkh_1\n  - requester_pkh_2\n</code></pre>"},{"location":"ops/deployment/#docker-compose_1","title":"Docker Compose","text":"<p>Use the compose file from <code>CD/moog-agent/docker-compose.yaml</code>:</p> <pre><code>services:\n  moog-agent:\n    image: ghcr.io/cardano-foundation/moog/moog-agent:${MOOG_VERSION:-latest}\n    secrets:\n      - agent-wallet\n      - secrets\n      - source: docker\n        target: /run/secrets/docker/config.json\n    environment:\n      - MOOG_MPFS_HOST=https://mpfs.plutimus.com\n      - MOOG_WALLET_FILE=/run/secrets/agent-wallet\n      - MOOG_TOKEN_ID=&lt;your-token-id&gt;\n      - MOOG_SECRETS_FILE=/run/secrets/secrets\n      - MOOG_WAIT=240\n      - MOOG_ANTITHESIS_USER=cardano\n      - DOCKER_CONFIG=/run/secrets/docker\n    restart: always\n    privileged: true\n    command: \"--poll-interval 60 --minutes 1440 --trust-all-requesters\"\n    volumes:\n      - tmp:/tmp\n      - /etc/ssl/certs/ca-certificates.crt:/etc/ssl/certs/ca-certificates.crt:ro\n      - /var/run/docker.sock:/var/run/docker.sock:rw\nsecrets:\n  agent-wallet:\n    file: /secrets/moog-agent/agent.json\n  secrets:\n    file: /secrets/moog-agent/secrets.yaml\n  docker:\n    file: /secrets/moog-agent/docker/config.json\nvolumes:\n  tmp:\n</code></pre> <p>Privileged mode and Docker socket</p> <p>The agent container requires privileged mode and access to the Docker socket because it runs <code>docker compose</code> to validate test assets locally before pushing them to Antithesis. See Security for implications.</p>"},{"location":"ops/deployment/#start-and-verify_1","title":"Start and verify","text":"<pre><code>export MOOG_VERSION=&lt;desired-version&gt;\ndocker compose up -d\ndocker compose logs -f moog-agent\n</code></pre> <p>The agent polls for pending test runs every <code>--poll-interval</code> seconds (default 60) and checks for email results within the <code>--minutes</code> window.</p>"},{"location":"ops/deployment/#environment-variables-reference","title":"Environment Variables Reference","text":"Variable Used by Description <code>MOOG_MPFS_HOST</code> oracle, agent URL of the MPFS service <code>MOOG_WALLET_FILE</code> oracle, agent Path to the wallet JSON file <code>MOOG_TOKEN_ID</code> oracle, agent The moog token asset ID on Cardano <code>MOOG_SECRETS_FILE</code> oracle, agent Path to <code>secrets.yaml</code> <code>MOOG_WAIT</code> oracle, agent Seconds between polling cycles <code>MOOG_ANTITHESIS_USER</code> agent Antithesis platform username <code>DOCKER_CONFIG</code> agent Path to Docker config directory (for private registries)"},{"location":"ops/deployment/#service-lifecycle","title":"Service Lifecycle","text":"<pre><code>sequenceDiagram\n    participant O as Oracle\n    participant M as MPFS\n    participant GH as GitHub\n    participant A as Agent\n    participant AT as Antithesis\n\n    loop Every MOOG_WAIT seconds\n        O-&gt;&gt;M: Query pending requests\n        O-&gt;&gt;GH: Validate requests (users, roles, repos)\n        O-&gt;&gt;M: Submit state update transaction\n    end\n\n    loop Every poll-interval seconds\n        A-&gt;&gt;M: Query pending test runs\n        A-&gt;&gt;GH: Download test assets\n        A-&gt;&gt;A: Local docker compose validation\n        A-&gt;&gt;AT: Push test to Antithesis\n        A-&gt;&gt;M: Report test acceptance\n    end\n\n    loop Every poll-interval seconds\n        A-&gt;&gt;A: Check email for results\n        A-&gt;&gt;M: Report test completion\n    end</code></pre>"},{"location":"ops/deployment/#pat-management","title":"PAT Management","text":"<p>GitHub Personal Access Tokens are required by both oracle and agent for GitHub API access.</p>"},{"location":"ops/deployment/#scope-requirements","title":"Scope requirements","text":"<ul> <li><code>repo</code> \u2014 needed to access repository contents, CODEOWNERS files, and user profile repos</li> </ul>"},{"location":"ops/deployment/#rotation","title":"Rotation","text":"<p>PATs have an expiration date. When a PAT expires:</p> <ol> <li>The oracle/agent will receive 401 errors from GitHub API</li> <li>All validation requests will fail</li> <li>The service will continue polling but accomplish nothing, burning rate limit on failed auth</li> </ol> <p>To rotate a PAT:</p> <ol> <li>Create a new PAT at github.com/settings/tokens</li> <li>Update <code>secrets.yaml</code> with the new token</li> <li>Restart the service: <code>docker compose restart</code></li> </ol> <p>Set a calendar reminder</p> <p>Create a reminder 1 week before PAT expiry to avoid service disruption.</p>"},{"location":"ops/deployment/#rate-limits","title":"Rate limits","text":"<p>GitHub API has a per-user rate limit of 5,000 requests/hour. This limit is shared across all PATs belonging to the same GitHub user. If both oracle and agent use PATs from the same user, they share the 5,000 request budget.</p> <p>See Troubleshooting for diagnosing PAT issues.</p>"},{"location":"ops/deployment/#monitoring","title":"Monitoring","text":""},{"location":"ops/deployment/#log-checking","title":"Log checking","text":"<pre><code># Oracle logs\ndocker compose logs --tail 50\n\n# Agent logs\ndocker compose logs --tail 50\n</code></pre>"},{"location":"ops/deployment/#health-verification","title":"Health verification","text":"<pre><code># Check pending requests\nmoog token | jq '.requests | length'\n\n# Check system facts\nmoog facts test-runs pending --pretty\n\n# Check GitHub rate limit\ncurl -s -H \"Authorization: token &lt;PAT&gt;\" \\\n  https://api.github.com/rate_limit | jq '.rate'\n</code></pre>"},{"location":"ops/deployment/#updating","title":"Updating","text":""},{"location":"ops/deployment/#image-version-bump","title":"Image version bump","text":"<pre><code>export MOOG_VERSION=&lt;new-version&gt;\ndocker compose pull\ndocker compose up -d\n</code></pre>"},{"location":"ops/deployment/#configuration-changes","title":"Configuration changes","text":"<p>For changes to <code>secrets.yaml</code> or environment variables, restart the service:</p> <pre><code>docker compose restart\n</code></pre> <p>No state is lost on restart \u2014 the service resumes polling from the current on-chain state.</p>"},{"location":"ops/intro/","title":"Introduction","text":"<p>This operations manual explains how to create and operate a Moog portal. </p> <p>Operating Moog requires:</p> <ul> <li>having an Antithesis account in which to execute   test runs</li> <li>running several services</li> <li>an oracle process, which represents the specific portal, and knows how to query     GitHub in order to verify claims made by users</li> <li>an agent process, which forward test-runs to Antithesis platform and report results back</li> <li>an MPFS service which stores the details about the transactions between     users and the portal on the Cardano blockchain     (MPFS is the Merkle Patricia     Forestry Service, an HTTP service which manages, through smart contracts, a     data structure called a Merkle Patricia Forestry on the blockchain).</li> <li>interventions by a human agent, for example to whitelist the GitHub   repository of a new user.</li> </ul> <p>The details of how to do all this are described in the rest of the Operations Manual.</p> <p>Moog infrastructure is currently operated by the Cardano Foundation while the project is still in its experimental phase. Those instructions are however useful for anyone interested in operating Moog.</p>"},{"location":"ops/oracle-role/","title":"Oracle role manual","text":"<p>This is the role of the user that wants to run a service to control access to the Antithesis platform. There will be only one token and so there will be only one oracle service running at a time, but we document it here for completeness.</p>"},{"location":"ops/oracle-role/#oracle-processing-loop","title":"Oracle Processing Loop","text":"<pre><code>flowchart TB\n    sleep[Sleep MOOG_WAIT seconds] --&gt; poll[Query MPFS for pending requests]\n    poll --&gt; validate[Validate each request against GitHub]\n    validate --&gt; submit[Submit batch state update transaction]\n    submit --&gt; sleep\n\n    validate --&gt;|user profile check| GH[GitHub API]\n    validate --&gt;|CODEOWNERS check| GH\n    validate --&gt;|repo contents check| GH\n    submit --&gt; MPFS[(MPFS Service)]</code></pre>"},{"location":"ops/oracle-role/#running-the-oracle-service","title":"Running the oracle service","text":"<p>You can build an executable that will continuously check for pending requests and include them in the Antithesis token.</p>"},{"location":"ops/oracle-role/#build","title":"Build","text":"<p>You can build the oracle service via nix:</p> <pre><code>nix build .#moog-oracle\n</code></pre> <p>On a linux machine you can build a docker container</p> <pre><code>nix build .#moog-oracle-docker-image\ndocker load &lt; result\n</code></pre> <p>Then you can run the docker container</p> <pre><code>version=$(nix eval .#version --raw)\ndocker run ghcr.io/cardano-foundation/moog/moog-oracle:$version\n</code></pre>"},{"location":"ops/oracle-role/#running-as-docker-service","title":"Running as Docker Service","text":"<p>For production deployment, use Docker Compose. See the Deployment Guide for full setup instructions including secrets, docker-compose configuration, and startup verification.</p>"},{"location":"ops/oracle-role/#running-oracle-commands-manually","title":"Running oracle commands manually","text":"<p>Alternatively, oracle commands can be run manually, using the <code>moog</code> CLI. See the Installation instructions for how to install it.</p>"},{"location":"ops/oracle-role/#creating-the-moog-token-only-once","title":"Creating the moog token (only once)","text":"<p>Oracle operations need a wallet. Since the oracle role is critical, in addition to setting the <code>MOOG_WALLET_FILE</code> environment variable to point to the wallet file, you should also set the <code>MOOG_WALLET_PASSPHRASE</code> environment variable to encrypt the wallet.</p> <p>You can create a wallet with the <code>moog wallet create</code> command.</p> <pre><code>moog wallet create\n</code></pre> <p>You can check the wallet info with:</p> <pre><code>moog wallet info\n</code></pre> <p>Example output:</p> <pre><code>{\n  \"address\": \"addr_test1...\",\n  \"filePath\": \"tmp/oracle.json\",\n  \"owner\": \"1f5cebecb4cd1cad6108a86014de9d8f23f9d4477bbddb3e1289b224\"\n}\n</code></pre> <p>To create the Antithesis token, you can use the <code>moog oracle token create</code> command.</p> <pre><code>moog oracle token boot\n</code></pre> <p>It will create the Antithesis token. This token is a unique identifier for the Antithesis platform and will be used by all users to interact with the platform. You have to distribute it so that users can set the <code>MOOG_TOKEN_ID</code> environment variable to point to it.</p> <p>You can review the token info anytime with</p> <pre><code>moog token | jq .state\n</code></pre> <p>Critically the owner matches the wallet owner.</p>"},{"location":"ops/oracle-role/#updating-the-moog-token","title":"Updating the moog token","text":"<p>The main responsibility of the oracle is to include change requests in the Antithesis token.</p> <p>Pending change requests can be queried with the <code>moog token</code> command.</p> <pre><code>moog token | jq '.requests'\n</code></pre> <p>In the requests field you will notice the <code>validation</code> field, which will be set to <code>validated</code> for all requests that have been validated .</p> <p>Once you decided what to include in the Antithesis token, you can commit the requests to the token.</p> <p>Updating the token with new requests is done with the <code>moog oracle token update</code> command. As with retract you have to provide the <code>outputRefId</code> of the request you want to update. Multiple requests can be updated at once, so you can provide multiple <code>-o</code> options.</p> <pre><code>moog oracle token update -o b6fc7cca5bcae74e6a5983f7922d0e0985285f1f19e62ccc9cb9fd4d3766a81b-0\n</code></pre>"},{"location":"ops/oracle-role/#deleting-the-moog-token-dangerous","title":"Deleting the moog token (DANGEROUS)","text":"<p>To delete the Antithesis token, you can use the <code>moog oracle token delete</code> command.</p> <pre><code>moog oracle token delete\n</code></pre>"},{"location":"ops/oracle-role/#publishing-the-oracle-configuration","title":"Publishing the oracle configuration","text":"<p>Before requesters can request test-runs, the oracle should select the agent identity and in general expose validation parameters so that the requesters and the agent can pre-validate their requests.</p> <p>This is done with the <code>moog oracle config set</code> command.</p> <pre><code>moog oracle config set  --min-test-duration MIN_TEST_HOURS --max-test-duration MAX_TEST_HOURS --agent-pkh PUBLIC_KEY_HASH\n</code></pre> <p>In this situation the oracle is acting like a user and so this request will end up in the Antithesis token as a request for change.</p> <p>Apply the token update command to commit the request to the Antithesis token</p> <p>This will end up in a fact and so anyone can inspect it with the <code>moog facts</code> command.</p> <pre><code>moog facts config\n</code></pre>"},{"location":"ops/protocol/","title":"Moog Protocol","text":""},{"location":"ops/protocol/#context","title":"Context","text":"<ul> <li><code>alice</code> is a user who wants to run tests in Antithesis for her cardano-node</li> <li><code>antithesis</code> is an agent that controls and monitors test-run's on the antithesis platform</li> <li><code>token</code> is a stateful unique token locked on-chain tracking the interactions between <code>alice</code> and <code>antithesis</code>. As a side effect it tracks also alice github credentials and alice github roles. It's a fact container, with a smart contract controlling the update process of the facts.</li> <li><code>oracle</code> is an agent in charge of the <code>token</code> updates. It does everything in its power to prevent inconsistent data to enter/exit the <code>token</code>.</li> </ul>"},{"location":"ops/protocol/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>sequenceDiagram\n    participant GitHub as Github Platform\n    actor Alice\n    actor Oracle\n    participant Token as Cardano Token\n    actor Antithesis\n    participant AntithesisPlatform as Antithesis Platform\n\n\n    %% Step 1: Alice registers as an identified user\n    Alice-&gt;&gt;+GitHub: Add an Ed25519 SSH key to github profile\n    Alice-&gt;&gt;+Token: moog requester register-user\n    Oracle-&gt;&gt;+GitHub: Validate alice credentials\n    Oracle-&gt;&gt;+Token: moog oracle token update\n\n    %% Step 2: Alice registers role as an antithesis test runner\n    Alice-&gt;&gt;+GitHub: Add herself under Antithesis key in CODEOWNERS file in her repository\n    Alice-&gt;&gt;+Token: moog requester register-role\n    Oracle-&gt;&gt;+GitHub: Validate alice role in CODEOWNERS\n    Oracle-&gt;&gt;+Token: moog oracle token update\n\n    %% Step 3: Agent white-list alice repository\n    Antithesis-&gt;&gt;+Token: moog agent white-list\n    Oracle-&gt;&gt;+Token: Validate antithesis identity\n\n    %% Step 4: Alice requests test runs\n    loop alice test runs request\n    Alice-&gt;&gt;+Token: moog requester create-test\n    Oracle-&gt;&gt;+Token: Check alice is maintainer\n    Oracle-&gt;&gt;+Token: Check platform/repo/commit prefix and run-index\n    Oracle-&gt;&gt;+Token: Validate alice SSH signature of the request\n    Oracle-&gt;&gt;+Token: moog oracle token update\n\n    %% Step 5: Antithesis processes test run request\n    alt Antithesis rejects request\n        Antithesis-&gt;&gt;+Token: moog agent reject-test\n        Oracle-&gt;&gt;+Token: Validate antithesis identity and test state\n        Oracle-&gt;&gt;+Token: moog oracle token update\n    else Antithesis accepts request\n        Antithesis-&gt;&gt;+AntithesisPlatform: Start test run\n        Antithesis-&gt;&gt;+Oracle: moog agent accept-test\n        Oracle-&gt;&gt;+Token: Validate antithesis identity and test state\n        Oracle-&gt;&gt;+Token: moog oracle token update\n    end\n\n    %% Step 6: Antithesis updates test run results\n    Antithesis-&gt;&gt;+AntithesisPlatform: Poll platform for test results\n    Antithesis-&gt;&gt;+Token: moog agent report-test\n    Oracle-&gt;&gt;+Token: Validate antithesis identity and test state\n    Oracle-&gt;&gt;+Token: moog oracle token update\n    end</code></pre>"},{"location":"ops/real-world/","title":"Real-World Scenario","text":"<p>This manual describes a real-world scenario, involving an interaction between the three roles involved in using the system (requester, agent and oracle). It is based on an end-to-end test bash script.</p>"},{"location":"ops/real-world/#pre-requisites","title":"Pre-requisites","text":"<p>The following scenario assumes that each role has fulfilled its pre-requisites, e.g.:</p> <ul> <li><code>moog</code> command is available</li> <li>wallet created and funded</li> <li>environment variables have been set</li> </ul> <p>For details of how to achieve this, see configuration.</p>"},{"location":"ops/real-world/#the-scenario","title":"The Scenario","text":""},{"location":"ops/real-world/#setting-up-an-interface","title":"Setting up an interface","text":"<p>To bootstrap the system, the oracle must create an moog token:</p> <pre><code>moog oracle token boot\n</code></pre> <p>This token is unique for a system. It enables all the actors to collaborate. It needs to be shared by some means with users. For example, the one that has been created (currently on preprod) for this project (an interface the the moogthesis instance managed by Cardano Foundation) is provided in the configuration. In order to \"connect\" to this interface all roles need to set the MOOG_TOKEN_ID environment variable to the value that was returned by the above command.</p> <p>Then, the agent must configure this interface on-chain, in particular test durations and the public key hash of the agent:</p> <pre><code>agent=$(moog wallet info | jq -r '.owner')\nexport MOOG_AGENT_PUBLIC_KEY_HASH=$agent\nmoog oracle config set \\\n    --min-test-duration 1 \\\n    --max-test-duration 4 \\\n    --agent-pkh \"$MOOG_AGENT_PUBLIC_KEY_HASH\"\n</code></pre> <p>In other words, the identity of the agent for this interface is defined by providing the public key hash from their wallet.</p> <p>Now, the interface to the Antithesis instance is ready to be used by requesters.</p>"},{"location":"ops/real-world/#setting-up-a-test-repository","title":"Setting up a test repository","text":"<p>In order to be able to run tests, requesters must first register themselves, using their GitHub username (e.g. \"myghname\") and public key hash:</p> <pre><code>moog requester register-user \\\n    --platform github \\\n    --username myghname \\\n    --pubkeyhash  ABAAC3NeaC3CCAILjrzNvy85HbzXV2lsW2lkjsq3Nrj84kjp3puarZX\n</code></pre> <p>If the username and pubkeyhash are valid, this request will be added to a queue, which the oracle can then include by updating the token. When this has been done the user should appear when requesting facts:</p> <pre><code>moog facts users\n</code></pre> <p>This process (where requests must get validated by the oracle before they become facts) applies to all requests, and for the sake of conciseness we will omit to make this explicit in what follows.</p> <p>Although the user is now registered, it is not yet allowed to request test runs. For this it must be given a role, i.e. associated with a specific repository (containing test specifications and identifying this user in the CODEOWNERS file). To achieve this the requester now adds a request:</p> <pre><code>moog requester register-role \\\n    --platform github \\\n    --username myghname \\\n    --repository myghname/myghrepo\n</code></pre> <p>When the oracle includes this new request on the token, the last step is for the requester to ask the agent to whitelist this repository. This would be the result of an informal discussion over on our Discord channel, or by sending an email to [hal\\@cardanofoundation.org][]. When the agent has decided to whitelist the repository, they invoke:</p> <pre><code>moog agent white-list \\\n    --platform github \\\n    --repository myghname/myghrepo\n</code></pre> <p>The result of the above set up can be verified with:</p> <pre><code>moog facts users\nmoog facts roles\nmoog facts white-list\n</code></pre> <p>The system is now ready to accept test run requests. The above only needs to be set up once (for a given requester and a given test repository). Then, the following commands (to run tests) can be performed repeatedly.</p>"},{"location":"ops/real-world/#running-tests-on-antithesis","title":"Running tests on Antithesis","text":"<p>The requester can now request to run an antithesis test.</p> <pre><code>moog requester create-test \\\n    --platform github \\\n    --username myghname \\\n    --repository myghname/myghrepo \\\n    --directory antithesis-test \\\n    --commit a7741a44dfddfe05822e1a49862ceea43ecd657d \\\n    --try 1 \\\n    --duration 1\n</code></pre> <p>This request must be accepted or rejected by the agent. The agent can inspect the repository and the specified directory in order to determine whether they contain valid specifications for an antithesis test.</p> <p>For example, to reject the test run with no reason, the agent would invoke:</p> <pre><code>validation=$(moog agent query)\nreferences=$(echo \"$validation\" | jq -r '.pending | .[] | .id')\nmoog agent reject-test -i \"$references\"\n</code></pre> <p>If this happens, the requester can try to improve the test code and try a second request:</p> <pre><code>moog requester create-test \\\n    --platform github \\\n    --username myghname \\\n    --repository myghname/myghrepo \\\n    --directory antithesis-test \\\n    --commit a7741a44dfddfe05822e1a49862ceea43ecd657d \\\n    --try 2 \\\n    --duration 1\n</code></pre> <p>Supposing the agent now sees that the repository contains a better test scenario, the agent could accept the test run by invoking:</p> <pre><code>validation=$(moog agent query)\nreferences=$(echo \"$validation\" | jq -r '.pending | .[] | .id')\nmoog agent accept-test -i \"$references\"\n</code></pre> <p>When Antithesis has finished the test run, the agent should publish the results:</p> <pre><code>validation=$(moog agent query)\nreferences=$(echo \"$validation\" | jq -r '.running | .[] | .id')\nmoog agent report-test -i \"$references\" \\\n    --duration 1 \\\n    --url \"https://example.com/report\"\n</code></pre>"},{"location":"ops/security/","title":"Security Considerations","text":""},{"location":"ops/security/#threat-model","title":"Threat Model","text":"<pre><code>flowchart TB\n    subgraph Attack Surfaces\n        pat[GitHub PAT compromise]\n        mpfs_trust[Malicious MPFS operator]\n        docker_priv[Docker privileged escalation]\n        wallet_theft[Wallet file theft]\n        rate_abuse[Rate limit exhaustion]\n    end\n\n    pat --&gt; impersonate[Impersonate user on GitHub]\n    pat --&gt; rate_abuse\n    mpfs_trust --&gt; alter_tx[Alter unsigned transactions]\n    docker_priv --&gt; host_escape[Container-to-host escape]\n    wallet_theft --&gt; drain[Drain wallet funds]\n    rate_abuse --&gt; dos[Denial of service for all tokens]</code></pre>"},{"location":"ops/security/#remote-mpfs-service","title":"Remote MPFS Service","text":"<p>The MPFS service is not able to sign transactions for the user. Nevertheless the current implementation doesn't perform any intent-check on the unsigned transactions it receives. Therefore, when using a remote MPFS service, users should ensure that they trust the operator of the service, as a malicious operator could potentially alter the unsigned transactions before sending them back to the user.</p> <p>To improve the situation an issue is open in GitHub.</p>"},{"location":"ops/security/#pat-management","title":"PAT Management","text":"<p>GitHub Personal Access Tokens are used by the oracle and agent to validate requests against GitHub (checking user profiles, CODEOWNERS, downloading assets).</p>"},{"location":"ops/security/#scope-requirements","title":"Scope requirements","text":"<p>PATs should be created with the minimum required scope:</p> <ul> <li><code>repo</code> \u2014 access to repository contents, CODEOWNERS files, and user profile repos</li> </ul>"},{"location":"ops/security/#rotation","title":"Rotation","text":"<p>PATs expire. An expired PAT causes silent failures \u2014 the service continues polling but all GitHub validation fails, burning rate limit requests on 401 responses.</p> <ul> <li>Set PAT expiry to 90 days and create a calendar reminder 1 week before</li> <li>To rotate: update <code>githubPAT</code> in <code>secrets.yaml</code> and restart the service</li> <li>See Troubleshooting for diagnosis</li> </ul>"},{"location":"ops/security/#shared-rate-limits","title":"Shared rate limits","text":"<p>GitHub API rate limits (5,000 requests/hour) are per-user, not per-token. All PATs belonging to the same GitHub user share one budget. If oracle and agent both use PATs from the same GitHub user, they compete for the same 5,000 requests.</p> <p>Recommendation: Use PATs from different GitHub users for oracle and agent services.</p>"},{"location":"ops/security/#docker-security","title":"Docker Security","text":"<p>The agent container runs with privileged mode and mounts the Docker socket from the host. This is required because the agent validates test assets by running <code>docker compose up --build</code> locally before pushing to Antithesis.</p>"},{"location":"ops/security/#implications","title":"Implications","text":"<ul> <li>Container-to-host escape: A compromised agent container with privileged mode and Docker socket access has effective root access to the host machine.</li> <li>Image pull/push: The agent has Docker registry credentials (via <code>DOCKER_CONFIG</code>) that could be used to access private registries.</li> </ul>"},{"location":"ops/security/#mitigations","title":"Mitigations","text":"<ul> <li>Run the agent on a dedicated machine or VM, not on shared infrastructure</li> <li>Use read-only mounts where possible (CA certs are already mounted <code>:ro</code>)</li> <li>Monitor Docker socket usage through host-level auditing</li> <li>Restrict network access from the agent machine to only required endpoints</li> </ul>"},{"location":"ops/security/#wallet-security","title":"Wallet Security","text":"<p>Oracle and agent wallets hold ADA needed for submitting Cardano transactions. They should contain only the minimum balance needed for operations.</p>"},{"location":"ops/security/#passphrase-protection","title":"Passphrase protection","text":"<p>Wallets can be encrypted with a passphrase. When encrypted, provide the passphrase via <code>secrets.yaml</code>:</p> <pre><code>walletPassphrase: your_passphrase\n</code></pre>"},{"location":"ops/security/#file-permissions","title":"File permissions","text":"<p>Wallet files and <code>secrets.yaml</code> should have restricted permissions:</p> <pre><code>chmod 600 /secrets/moog-oracle/oracle.json\nchmod 600 /secrets/moog-oracle/secrets.yaml\nchmod 600 /secrets/moog-agent/agent.json\nchmod 600 /secrets/moog-agent/secrets.yaml\n</code></pre> <p>In Docker Compose, these are mounted as Docker secrets (under <code>/run/secrets/</code>), which provides isolation from the container filesystem.</p>"},{"location":"ops/troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and how to resolve them.</p>"},{"location":"ops/troubleshooting/#diagnostic-flowchart","title":"Diagnostic Flowchart","text":"<pre><code>flowchart TD\n    start[Service not working] --&gt; logs[Check docker compose logs]\n    logs --&gt; auth_err{401/403 errors?}\n    auth_err --&gt;|Yes| pat[PAT expired or rate-limited]\n    auth_err --&gt;|No| pending{Requests accumulating?}\n    pending --&gt;|Yes| stale[Stale pending requests]\n    pending --&gt;|No| poll{Polling but no action?}\n    poll --&gt;|Yes| config[Check env vars and secrets]\n    poll --&gt;|No| stuck{Agent changing state errors?}\n    stuck --&gt;|Yes| agent_stuck[Agent stuck in state transition]\n    stuck --&gt;|No| other[Check MPFS service availability]</code></pre>"},{"location":"ops/troubleshooting/#pat-expired-or-rate-limited","title":"PAT Expired or Rate-Limited","text":""},{"location":"ops/troubleshooting/#symptoms","title":"Symptoms","text":"<ul> <li>401 Unauthorized or 403 Forbidden errors in logs</li> <li>Oracle validates no requests despite pending ones existing</li> <li>Agent fails to download test assets</li> <li>Rate limit header shows <code>remaining: 0</code></li> </ul>"},{"location":"ops/troubleshooting/#diagnosis","title":"Diagnosis","text":"<p>Check the PAT validity and rate limit status:</p> <pre><code># Check rate limit (replace &lt;PAT&gt; with your token)\ncurl -s -H \"Authorization: token &lt;PAT&gt;\" \\\n  https://api.github.com/rate_limit | jq '.rate'\n</code></pre> <p>Expected output: <pre><code>{\n  \"limit\": 5000,\n  \"remaining\": 4832,\n  \"reset\": 1708300000,\n  \"used\": 168\n}\n</code></pre></p> <p>If <code>remaining</code> is 0 or the request returns 401, the PAT is expired or rate-limited.</p>"},{"location":"ops/troubleshooting/#fix","title":"Fix","text":"<ol> <li>If expired: Create a new PAT at github.com/settings/tokens with <code>repo</code> scope</li> <li>Update <code>secrets.yaml</code>:    <pre><code>githubPAT: ghp_new_token_here\n</code></pre></li> <li>Restart the service:    <pre><code>docker compose restart\n</code></pre></li> </ol> <p>Rate limit is per-user, not per-token</p> <p>If oracle and agent use PATs from the same GitHub user, they share the 5,000 requests/hour budget. Consider using PATs from different GitHub users for oracle and agent.</p>"},{"location":"ops/troubleshooting/#stale-pending-requests","title":"Stale Pending Requests","text":""},{"location":"ops/troubleshooting/#symptoms_1","title":"Symptoms","text":"<ul> <li>Multiple pending requests visible in <code>moog facts test-runs pending</code></li> <li>Requests have been pending for longer than expected (hours/days)</li> <li>Oracle logs show it is polling but not processing requests</li> </ul>"},{"location":"ops/troubleshooting/#diagnosis_1","title":"Diagnosis","text":"<p>Check how many requests are pending:</p> <pre><code>moog facts test-runs pending --pretty\n</code></pre> <p>Check oracle logs for validation errors:</p> <pre><code>docker compose logs --tail 100 | grep -i \"error\\|fail\\|reject\"\n</code></pre>"},{"location":"ops/troubleshooting/#fix_1","title":"Fix","text":"<p>If the oracle is down or the PAT was expired for an extended period, requests may have accumulated. There are two approaches:</p> <p>Option 1: Fix the oracle and let it catch up</p> <p>Once the oracle is running with a valid PAT, it will process all pending requests in subsequent polling cycles.</p> <p>Option 2: Retract stale requests</p> <p>If requests are no longer relevant, the requester can retract them:</p> <pre><code>moog retract -o &lt;output-ref-id&gt;\n</code></pre> <p>The <code>output-ref-id</code> can be found in the pending requests output.</p>"},{"location":"ops/troubleshooting/#oracle-polling-failures","title":"Oracle Polling Failures","text":""},{"location":"ops/troubleshooting/#symptoms_2","title":"Symptoms","text":"<ul> <li>Oracle container is running but logs show repeated errors</li> <li>No state updates happening on-chain</li> <li>Pending requests keep accumulating</li> </ul>"},{"location":"ops/troubleshooting/#diagnosis_2","title":"Diagnosis","text":"<pre><code># Check oracle is running\ndocker compose ps\n\n# Check recent logs\ndocker compose logs --tail 50 moog-oracle\n\n# Verify MPFS is reachable\ncurl -s https://mpfs.plutimus.com/health\n</code></pre>"},{"location":"ops/troubleshooting/#common-causes","title":"Common causes","text":"Cause Log indicator Fix MPFS unreachable Connection refused / timeout Check MPFS service, check <code>MOOG_MPFS_HOST</code> Invalid wallet Wallet decode error Verify <code>MOOG_WALLET_FILE</code> path and file contents Wrong token ID Token not found Verify <code>MOOG_TOKEN_ID</code> matches the deployed token Expired PAT 401/403 from GitHub Rotate PAT in <code>secrets.yaml</code>, restart Insufficient funds Balance too low Send ADA to the oracle wallet address"},{"location":"ops/troubleshooting/#agent-stuck-in-state-transition","title":"Agent Stuck in State Transition","text":""},{"location":"ops/troubleshooting/#symptoms_3","title":"Symptoms","text":"<ul> <li>Agent logs show errors when trying to accept or report a test</li> <li>Test stuck in <code>pending</code> or <code>running</code> state</li> <li>Transaction submission failures</li> </ul>"},{"location":"ops/troubleshooting/#diagnosis_3","title":"Diagnosis","text":"<pre><code># Check agent logs\ndocker compose logs --tail 100 moog-agent\n\n# Check current test run states\nmoog facts test-runs pending --pretty\nmoog facts test-runs running --pretty\n</code></pre>"},{"location":"ops/troubleshooting/#common-causes_1","title":"Common causes","text":"<ul> <li>Insufficient funds in agent wallet \u2014 send ADA to the agent wallet address</li> <li>MPFS transaction conflicts \u2014 another transaction was submitted concurrently; the agent will retry on next poll</li> <li>Antithesis API errors \u2014 check if Antithesis platform is reachable and credentials are valid</li> </ul>"},{"location":"ops/troubleshooting/#rate-limit-monitoring","title":"Rate Limit Monitoring","text":""},{"location":"ops/troubleshooting/#check-current-rate-limit","title":"Check current rate limit","text":"<pre><code>curl -s -H \"Authorization: token &lt;PAT&gt;\" \\\n  https://api.github.com/rate_limit | jq '{\n    limit: .rate.limit,\n    remaining: .rate.remaining,\n    used: .rate.used,\n    resets_at: (.rate.reset | todate)\n  }'\n</code></pre>"},{"location":"ops/troubleshooting/#estimate-consumption","title":"Estimate consumption","text":"<p>Each oracle polling cycle makes approximately:</p> <ul> <li>1 request to check pending requests</li> <li>N requests for GitHub validation (per pending request: user profile, CODEOWNERS, repo contents)</li> </ul> <p>Each agent polling cycle makes approximately:</p> <ul> <li>1 request to check pending test runs</li> <li>2-3 requests per test run to download assets</li> </ul> <p>With a 60-second poll interval and 10 pending requests, the agent alone could use ~1,800 requests/hour.</p> <p>Reduce rate limit usage</p> <p>Increase <code>--poll-interval</code> or <code>MOOG_WAIT</code> to reduce API call frequency when rate limits are a concern.</p>"},{"location":"user/ci/","title":"Continuous Integration","text":"<p>Moog can be easily integrated in a Continuous Integration process to trigger Antithesis tests run on demand. Here is some example configuring GitHub actions but this should be straightforward to adapt to any other kind of CI engine.</p> <p>These tests are triggered every 6 hours</p> <pre><code>name: \"Antithesis Tests\"\non:\n  schedule:\n    # run every 6 hours\n    - cron:  '5 1,7,13,19 * * *'\n</code></pre> <p>Linux/x86 is currently the best supported platform by Moog.</p> <pre><code>jobs:\n  run-antithesis:\n    runs-on: ubuntu-latest\n</code></pre> <p>We need to define a number of environment variables that will be used by Moog requester to request tests run. The detailed meaning of these variables is explained in the usage section of the documentation:</p> <pre><code>    env:\n      MOOG_WALLET_FILE: ${{ vars.MOOG_WALLET_FILE }}\n      MOOG_MPFS_HOST: ${{ vars.MOOG_MPFS_HOST }}\n      MOOG_TOKEN_ID: ${{ vars.MOOG_TOKEN_ID }}\n      MOOG_PLATFORM: github\n      MOOG_REQUESTER: ${{ vars.MOOG_REQUESTER }}\n      MOOG_TEST_DIRECTORY: ${{ vars.MOOG_TEST_DIRECTORY }}\n</code></pre> <ul> <li><code>MOOG_WALLET_FILE</code> is the file that will store the mnemonics of the wallet used to pay transaction fees</li> <li><code>MOOG_MPFS_HOST</code> is the URL of the Merkle-Patricia Forestry Service Moog shall use to retrieve information about the system's state</li> <li><code>MOOG_TOKEN_ID</code> is the identifier of the particular \"database\" Moog will be using (a 32-bytes hash denoting a Cardano native asset name)</li> <li><code>MOOG_PLATFORM</code> is hardcoded to <code>github</code> as this is currently the only supported source forge</li> <li><code>MOOG_REQUESTER</code> is the username under which the tests will be run. Note this name must both exist in the platform and be registered with Moog</li> <li><code>MOOG_TEST_DIRECTORY</code> points at a directory in the source code which contains a valid Antithesis <code>docker-compose.yaml</code> configuration file for tests submission</li> </ul> <p>We also need to set some secrets that will be used by Moog to authenticate and authorize the requests:</p> <pre><code>      MOOG_GITHUB_PAT: ${{ secrets.MOOG_GITHUB_PAT }}\n      MOOG_REQUESTER_WALLET: ${{ secrets.MOOG_REQUESTER_WALLET }}\n</code></pre> <ul> <li><code>MOOG_REQUESTER_WALLET</code> is the base64-encoded JSON content of the wallet file created by <code>moog wallet create</code>, typically the mnemonics (see Configuration)</li> <li><code>MOOG_GITHUB_PAT</code> is obviously specific to <code>github</code> platform and is a Personal Authentication Token used to query Github API</li> </ul> <p>We set a timeout of 10 hours for this job as we'll be waiting for test execution result, adjust accordingly</p> <pre><code>    timeout-minutes: 600\n</code></pre> <p>These are the permissions we need for this job and which will be set for the particular token attached to it</p> <pre><code>    # required permissions to be able to push to registry\n    permissions:\n      packages: write\n      contents: read\n      attestations: write\n      id-token: write\n</code></pre> <p>Now come the sequence of actions needed to run the tests. We first do some setup for docker, and checkout the code</p> <pre><code>    steps:\n    - name: \ud83d\udea7 Set up Docker Buildx\n      uses: docker/setup-buildx-action@v3\n\n    - name: \ud83d\udce5 Checkout repository\n      uses: actions/checkout@v4\n      with:\n        ref: ${{ github.event.inputs.ref_name || '' }}\n\n    - name: \ud83d\udd11 Login Docker Registry\n      uses: docker/login-action@v3\n      with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>We then identify the latest available release of Moog,</p> <pre><code>    - id: moog\n      name: Get latest moog release tag\n      uses: pozetroninc/github-action-get-latest-release@master\n      with:\n        repository: cardano-foundation/moog\n</code></pre> <p>retrieve it from GitHub packages,</p> <pre><code>    - name: Download moog from latest release\n      uses: robinraju/release-downloader@v1.10\n      with:\n        repository: cardano-foundation/moog\n        tag: ${{ steps.moog.outputs.release }}\n        fileName: \"moog-*-linux64.tar.gz\"\n        out-file-path: \".\"\n        extract: true\n</code></pre> <p>and ultimately install <code>moog</code> executable to be available for later steps.</p> <pre><code>    - name: Install moog\n      run: |\n        echo \"Release: ${{ steps.moog.outputs.release }}\"\n        sudo install -m 0755 moog /usr/local/bin/moog\n        moog --version\n</code></pre> <p>The wallet's secret (mnemonics) are extracted and temporarily stored in the local filesystem for use by Moog.</p> <pre><code>    - name: Configure moog wallet\n      run: printf '%s' \"$MOOG_REQUESTER_WALLET\" | base64 --decode &gt; $MOOG_WALLET_FILE\n</code></pre> <p>Finally, we are able to submit our test request:</p> <pre><code>    - name: Submit test\n      id: request\n      run: |\n        set -euo pipefail\n</code></pre> <p>This part of the script computes the trial number for this test run. Test runs are identified by the Git commit SHA plus a trial number in order to avoid duplicate requests. We use the <code>moog facts test-runs</code> command parameterised by the user id to retrieve relevant data.</p> <pre><code>        TRY=$(moog facts test-runs --whose $MOOG_REQUESTER | jq 'map(select(.key.commitId == \"${{ github.sha }}\")) | length')\n        TRY=$(($TRY + 1)) # start with try=1\n        echo \"TRY=$TRY\"\n</code></pre> <p>At last, we request test execution. <code>$DURATION</code> should be set to the requested duration (in hours) of the test run. If all goes well transaction and test run identifiers should be printed.</p> <pre><code>        RESULT=$(moog requester create-test -d \"$MOOG_TEST_DIRECTORY\" \\\n          -c ${{ github.sha }} \\\n          -r \"$GITHUB_REPOSITORY\" \\\n          --try $TRY \\\n          -t $DURATION)\n        echo $RESULT\n\n        # Passing -e and -r in separate jq calls ensures we both unwrap\n        # the string quotes and fail if the json isn't as expected.\n        ID=$(echo $RESULT | jq -e .value.testRunId | jq -r .)\n        TXID=$(echo $RESULT | jq -e .txHash | jq -r .)\n        echo \"id=$ID\" &gt;&gt; \"$GITHUB_OUTPUT\"\n        echo \"txHash=$TXID\" &gt;&gt; \"$GITHUB_OUTPUT\"\n</code></pre> <p>The last part of the job simply waits for the result to be published by the Antithesis agent, repeatedly running <code>moog facts test-runs --test-run-id \"$ID\"</code> command and checking its output to tell whether or not the test is finished.</p> <pre><code>    - name: Wait for results\n      run: timeout $((($DURATION + 1) * 3600)) ./scripts/wait-for-test.sh \"${{ steps.request.outputs.id }}\"\n</code></pre> <p>When the test completes, final result is printed in the logs along with the URL where the detailed Antithesis report can be found. The job succeeds if and only if the test <code>outcome</code> is a success.</p> <pre><code>final result: [{\"id\":\"722bb7a35a6b9318536b6750751e5f13ed6e1dcc83fd113d98cf4e4b02ea1e14\",\"key\":{\"commitId\":\"0ce357a0faabf970eb38d7191bf5f8bb8a36684b\",\"directory\":\"docker/testnet\",\"platform\":\"github\",\"repository\":{\"organization\":\"pragma-org\",\"repo\":\"amaru\"},\"requester\":\"abailly\",\"try\":2,\"type\":\"test-run\"},\"slot\":107737174,\"value\":{\"duration\":3,\"from\":{\"from\":{\"duration\":3,\"faults_enabled\":true,\"phase\":\"pending\",\"signature\":\"d1a70d0f60d358330f89d58c50f9971f16c54223d31932b3335561cd4efaecf4f9145c0f48f7098a66597062d7b558fe7785276cf67676bad0c787306b54be00\"},\"phase\":\"accepted\"},\"outcome\":\"failure\",\"phase\":\"finished\",\"url\":\"https://cardano.antithesis.com/report/F7dbAImlN-ZGCzC2_rkNKayN/Jw7X8mEfgH6iFqDy1W9jEDeSJ9rQWwAGN_y_eZ3oHwk.html?auth=v2.public.eyJuYmYiOiIyMDI1LTExLTE3VDIxOjU2OjEwLjI0NTMxNzAxNVoiLCJzY29wZSI6eyJSZXBvcnRTY29wZVYxIjp7ImFzc2V0IjoiSnc3WDhtRWZnSDZpRnFEeTFXOWpFRGVTSjlyUVd3QUdOX3lfZVozb0h3ay5odG1sIiwicmVwb3J0X2lkIjoiRjdkYkFJbWxOLVpHQ3pDMl9ya05LYXlOIn19ffVFhhos4dhGHfry7p0K54c_cOHbkxnJW3Il926JxHeMIh3rRZgjuBbMUlyfVCl7sEG1Sc6nNRHr36gTOfM0xAQ\"}}]\n&gt; **Note:** The following output is an example of a failed test run, shown to demonstrate the output format. In a successful run, you should see a message indicating that all tests passed.\nfailed\nError: Process completed with exit code 1.\n</code></pre>"},{"location":"user/configuration/","title":"Configuration","text":""},{"location":"user/configuration/#prerequisites","title":"Prerequisites","text":"<p>You must have previously installed Moog's CLI.</p>"},{"location":"user/configuration/#environment-variables-and-preliminaries","title":"Environment variables and preliminaries","text":""},{"location":"user/configuration/#mpfs-host","title":"MPFS host","text":"<p>If you do not want to host your own MPFS service, you can use a public one at <code>https://mpfs.plutimus.com</code>.</p> <p>In any case set the <code>MOOG_MPFS_HOST</code> environment variable to point to the MPFS service you want to use.</p> <pre><code>export MOOG_MPFS_HOST=https://mpfs.plutimus.com\n</code></pre>"},{"location":"user/configuration/#your-wallet","title":"Your wallet","text":"<p>Moog is a DApp that allows one to request Antithesis tests execution by posting transactions to Cardano blockchain (currently on preprod network). As such it requires a \"wallet\" to pay for fees and sign transactions.</p> <p>Currently the Moog CLI works only by reading a wallet file containing a mnemonic phrase.</p> <p>The <code>moog</code> command will read the wallet file from the <code>MOOG_WALLET_FILE</code> environment variable.</p> <pre><code>export MOOG_WALLET_FILE=wallet.json\n</code></pre> <p>Optionally you can provide a passphrase to encrypt the mnemonic phrase in the wallet file:</p> <p>Setting a passphrase is highly recommended to protect your wallet</p> <p>A less secure way to provide the passphrase is to set the <code>MOOG_WALLET_PASSPHRASE</code> environment variable:</p> <p><pre><code>read -s -p \"Enter your wallet passphrase: \" MOOG_WALLET_PASSPHRASE\nexport MOOG_WALLET_PASSPHRASE\n</code></pre> You can create a wallet file with the <code>moog wallet create</code> command:</p> <pre><code>moog wallet create\n</code></pre> <p>A more secure way is to let the CLI prompt you for the passphrase when needed.</p> <pre><code>moog wallet create --ask-wallet-passphrase\n</code></pre> <p>If you set the <code>MOOG_INTERACTIVE_SECRETS</code> environment variable to any value, the CLI will prompt you for the passphrase every time it needs it.</p> <pre><code>export MOOG_INTERACTIVE_SECRETS=1\n</code></pre> <p>You can review this wallet info anytime with</p> <pre><code>moog wallet info\n</code></pre> <p>You can encrypt the wallet's secret (if previously you chose to store it in unencrypted way, ie., you used <code>moog wallet create</code>) using</p> <pre><code>moog wallet encrypt path/to/encrypted/secret/file --ask-wallet-passphrase\n</code></pre> <p>Also, you can decrypt previously encrypted wallet's secret (if previously you chose to store it in encrypted way, ie., you used <code>moog wallet create --ask-wallet-passphrase</code>) using</p> <pre><code>moog wallet decrypt path/to/decrypted/secret/file\n</code></pre> <p>For the both cases <code>MOOG_WALLET_FILE</code> is set as before.</p> <p>Warning</p> <p>Store a copy of your encrypted/plaintext wallet file in a password manager. Think twice before storing a plaintext wallet file. Store your passphrase in a password manager too. Currently we do not support hardware wallets like Ledger or Trezor.</p> <p>Fund your wallet with some tAda tokens on preprod, for example using the Cardano Testnet Faucet.</p>"},{"location":"user/configuration/#antithesis-token","title":"Antithesis token","text":"<p>This is the unique token that identifies the (Cardano Foundation) Antithesis access interface. You need to refer to it setting the <code>MOOG_TOKEN_ID</code> environment variable.</p> <pre><code>export MOOG_TOKEN_ID=21c523c3b4565f1fc1ad7e54e82ca976f60997d8e7e9946826813fabf341069b\n</code></pre>"},{"location":"user/configuration/#set-the-timeout-for-the-moog-command","title":"Set the timeout for the <code>moog</code> command","text":"<p>When submitting txs to the chain, it's quite convenient to wait for the transaction to be included in the chain, so that you can immediately use the result of the transaction.</p> <p>To do that, you can set the <code>MOOG_WAIT</code> environment variable to the number of seconds you want to wait for the transaction to be included in the chain.</p> <pre><code>export MOOG_WAIT=120\n</code></pre>"},{"location":"user/configuration/#configuring-access-to-github","title":"Configuring access to GitHub","text":"<p>The tool will query the GitHub platform on your behalf in order to obtain (public) information about users, repositories and test assets as stored into repositories.</p> <p>In order to make this possible you must provide a GitHub Personal Access Token (PAT) for read-only access to public data. See the GitHub platform's documentation for how to create one.</p> <p>Provide your GitHub PAT to the tool by setting an environment variable:</p> <pre><code>export MOOG_GITHUB_PAT=\"github_pat_31A...&lt;snipped&gt;...xL\"\n</code></pre>"},{"location":"user/configuration/#querying-the-token-state","title":"Querying the token state","text":"<p>You can now query the state of the (Cardano Foundation) Antithesis token with the following command:</p> <pre><code>moog token\n</code></pre> <p>This will show - the token owner a.k.a. the oracle identity - the pending change requests - the root of the mpf tree - the current UTxO of the state</p>"},{"location":"user/configuration/#querying-facts-of-the-antithesis-token","title":"Querying facts of the Antithesis token","text":"<p>You can always query the Antithesis token and all its facts</p> <pre><code>moog facts\n</code></pre> <p>But you can also query specific facts, for example to report the GitHub registered users:</p> <pre><code>moog facts users\n</code></pre> <p>Or to query all test-run states:</p> <pre><code>moog facts test-runs\n</code></pre> <p>To report the pending test-runs:</p> <pre><code>moog facts test-runs pending\n</code></pre> <p>You can also query facts for a specific test-run id:</p> <pre><code>moog facts test-runs -i id1 -i id2 ..\n</code></pre> <p>This is useful if you stored the test-run id when you created the test-run. Test-run ids are facts ids so you can also look them up via <code>moog facts</code></p> <p>Finally</p> <p><pre><code>moog facts --help\n</code></pre> will show you all the available facts you can query.</p> <p>All facts come with their last-modification slot, that you can use to sort them. (Only externally via jq, currently)</p> <pre><code>moog facts test-runs | jq '[.[] | select(.key.repository.repo == \"moog\")] | sort_by(.slot) | last' | jq\n{\n  \"id\": \"1879281b7787d6e8cfc35e322510afd3438d53720e7e5731839deae2279e2f39\",\n  \"key\": {\n    \"commitId\": \"c5ce800a2a008237df21b4927d33f8b3d953f20b\",\n    \"directory\": \"compose/testnets/cardano_node_master\",\n    \"platform\": \"github\",\n    \"repository\": {\n      \"organization\": \"cardano-foundation\",\n      \"repo\": \"moog\"\n    },\n    \"requester\": \"cfhal\",\n    \"try\": 1,\n    \"type\": \"test-run\"\n  },\n  \"slot\": 106050979,\n  \"value\": {\n    \"duration\": 1,\n    \"from\": {\n      \"from\": {\n        \"duration\": 1,\n        \"phase\": \"pending\",\n        \"signature\": \"68d2457749aaeafea128f2fbdb05575ee1bb2961a2b4b42dc31631bcbdb29200a073a623ceedeb5ef770e1f79a6c92c5d0c6ccb023f89e60bbae4f794dafb20f\"\n      },\n      \"phase\": \"accepted\"\n    },\n    \"outcome\": \"success\",\n    \"phase\": \"finished\",\n    \"url\": \"Jqt4G6cEKgOH3n0nkNcN84jb/EU26UD1qMZRZpqB1uL7Fiaqab4X8EHnj1lEajxMOxMDd5CJejGBoBag09svp9zADaqYyXgwRSJFxjLYyZDbQVZL1QhUU6jRyAT79iFXzfUkq2mdvWX4ygsRZKklzZ0OD5qqF0SqTEjO8XT3l16NFlp5sqZJbTYzaWr2zxrpkcq3TJxMmGWrnrmgFFIvxw3G8ljZy3aNBEEt0AwUmVVf/PfNN+pp36paZtD2xOMoCBiDUeaTFeJt0r5laxsgVBzPJSWyj84yTiFZg7E+0cIxgRdx7A9PRrgFOwjXb+QQKPIOihCVauZga2fOLdS2mc6E9qGiApjm4q8Nv0Ii7VNiw3NYbINpW5VJ3XhE6gYWgV/sQWzPb3/kwofVgcCMAA7I9ADVA2EqFDRX6q5vqR99VZiLZsoMsyDIgoG2Rjm0/OwTbMsaNg5A9s73kJyRsPQG+/wK5slvSS1S2BfJ+e2NVzHJtHcyqMW/SgIZ7tSttFjNiyJRJKAVeRdhxVjP7yn5kJ5iHz2pGiSJYSlowRgsQ6XIVph0ce5E8GBEUB2IG2nQPo1FvRYMmSrx/k6aWIeS\"\n  }\n}\n</code></pre>"},{"location":"user/installation/","title":"Installation","text":""},{"location":"user/installation/#prerequisites","title":"Prerequisites","text":"<p>The Moog command-line-interface (CLI) can run on Linux and MacOS.</p>"},{"location":"user/installation/#installing-moogs-cli","title":"Installing Moog's CLI","text":"<p>The recommended way for end-users to install the Moog CLI is to download the pre-built binaries for your platform from the releases page</p> <p>Alternatively, if you are a Nix user you may run the CLI directly from the official repository:</p> <pre><code>nix shell github:cardano-foundation/moog?dir=cli#moog\n</code></pre> <p>For additional ways, see the CONTRIBUTING files in the source repository.</p> <p>After installation, you should be able to run:</p> <pre><code>moog --help\n</code></pre> <p>If this prints out Moog's CLI help, you have successfully installed the CLI.</p>"},{"location":"user/installation/#optional-cli-features","title":"Optional CLI features","text":"<p>You can enable bash completion for the <code>moog</code> command by adding the following line to your <code>.bashrc</code> or <code>.bash_profile</code> file:</p> <pre><code>source &lt;(moog --bash-completion-script \"$(which moog)\")\n</code></pre> <p>You can have a pretty output (not valid JSON,  but easier to read) by passing <code>--pretty</code> switch or setting the <code>MOOG_PRETTY</code> environment variable to any value:</p> <p>Be careful that, in general, <code>| jq</code>, will not work with this setting.</p> <pre><code>export MOOG_PRETTY=1\n</code></pre> <p>For scripting purposes you can disable the pretty effect of the env-var by passing <code>--no-pretty</code> switch.</p>"},{"location":"user/intro/","title":"Introduction","text":"<p>Moog provides a command-line-interface (CLI) tool which is used to interact with the Moog system.</p> <p>This user manual explains how to:</p> <ul> <li>Install the CLI tool.</li> <li>Configure your CLI tool, in particular so that it   interacts with your chosen Moog portal.</li> <li>Use Moog to submit Antithesis test run requests.</li> </ul>"},{"location":"user/secrets-management/","title":"Secrets management tips","text":""},{"location":"user/secrets-management/#secrets-in-docker-containers","title":"Secrets in docker containers","text":"<p>When passing secrets to a docker container in a compose you can use the <code>MOOG_SECRETS_FILE</code> environment variable to point to a file containing the secrets in yaml format. So instead of setting say <code>MOOG_SSH_PASSWORD</code> and <code>MOOG_GITHUB_PAT</code> you can create a file <code>secrets.yaml</code> with the following content:</p> <pre><code>sshPassword: your_ssh_password\ngithubPAT: your_github_pat\n</code></pre> <p>and then pass it to the container with something like:</p> <pre><code>services:\n  moog:\n    .....\n    environment:\n      - MOOG_SECRETS_FILE=/run/secrets/anti_secrets\n    secrets:\n      - anti_secrets\n\nsecrets:\n  anti_secrets:\n    file: ./secrets.yaml\n</code></pre>"},{"location":"user/secrets-management/#secrets-by-role","title":"Secrets by Role","text":"<pre><code>graph LR\n    subgraph secrets.yaml\n        pat[githubPAT]\n        wallet[walletPassphrase]\n        ssh[sshPassword]\n        anti[antithesisPassword]\n        email[agentEmail]\n        emailpw[agentEmailPassword]\n        slack[slackWebhook]\n        trusted[trustedRequesters]\n    end\n\n    Oracle --&gt; pat\n    Oracle --&gt; wallet\n    Agent --&gt; pat\n    Agent --&gt; wallet\n    Agent --&gt; anti\n    Agent --&gt; email\n    Agent --&gt; emailpw\n    Agent --&gt; slack\n    Agent --&gt; trusted\n    Requester --&gt; ssh\n    Requester --&gt; pat\n    Requester --&gt; wallet</code></pre> <p>Each role uses a different subset of the secrets. Below is the complete <code>secrets.yaml</code> structure for each role.</p>"},{"location":"user/secrets-management/#oracle-secretsyaml","title":"Oracle secrets.yaml","text":"<pre><code>githubPAT: ghp_xxxxxxxxxxxx        # GitHub PAT with repo scope\nwalletPassphrase: your_passphrase   # wallet encryption passphrase (if any)\n</code></pre>"},{"location":"user/secrets-management/#agent-secretsyaml","title":"Agent secrets.yaml","text":"<pre><code>agentEmail: agent@example.com             # email for receiving Antithesis results\nagentEmailPassword: xxxx-xxxx-xxxx-xxxx   # app password for the email account\ngithubPAT: ghp_xxxxxxxxxxxx              # GitHub PAT with repo scope\nantithesisPassword: your_password         # Antithesis registry/platform password\nwalletPassphrase: your_passphrase         # wallet encryption passphrase (if any)\nslackWebhook: https://hooks.slack.com/... # Slack notifications (optional)\ntrustedRequesters:                        # allowed requester PKHs (optional)\n  - pkh_1\n  - pkh_2\n</code></pre>"},{"location":"user/secrets-management/#requester-secretsyaml","title":"Requester secrets.yaml","text":"<pre><code>sshPassword: your_ssh_password      # SSH password for Git operations\ngithubPAT: ghp_xxxxxxxxxxxx        # GitHub PAT with repo scope\nwalletPassphrase: your_passphrase   # wallet encryption passphrase (if any)\n</code></pre>"},{"location":"user/secrets-management/#all-supported-keys","title":"All supported keys","text":"Key Used by Description <code>sshPassword</code> requester SSH password for Git operations <code>githubPAT</code> oracle, agent, requester GitHub Personal Access Token <code>walletPassphrase</code> oracle, agent, requester Wallet encryption passphrase <code>antithesisPassword</code> agent Antithesis platform/registry password <code>agentEmail</code> agent Email address for receiving test results <code>agentEmailPassword</code> agent App password for the email account <code>slackWebhook</code> agent Slack webhook URL for notifications <code>trustedRequesters</code> agent List of trusted requester public key hashes"},{"location":"user/usage/","title":"Usage","text":"<p>This describes Moog's usage for a user who wants to run tests using the Antithesis platform.</p> <p>Before you can request a test run, you need to register yourself as GitHub user with an SSH ed25519 public key.</p>"},{"location":"user/usage/#registrations","title":"Registrations","text":"<p>A couple of requests have to be made once before the regular test-run requests can succeed. These requests are used to register the user and the project on the Antithesis platform.</p> <p>Currently we only support GitHub as a platform, but we plan to support other platforms in the future.</p> <p>Registration and unregistrations can be requested by anyone. The oracle role will simply validate the facts against the GitHub platform and update the Antithesis token accordingly. You cannot register a user or project that is already registered.</p> <p>Be careful that there is no imperativity here, so i.e. you cannot unregister a user public key if it's present in GitHub.</p>"},{"location":"user/usage/#registering-a-user-public-key","title":"Registering a user public key","text":"<p>To register yourself as a user, you can use the <code>moog requester register-user</code> command.</p> <p>It's required that you publish an ed25519 public key in your GitHub account.</p> <p>First collect your wallet <code>vkey</code> <pre><code>export MYPK=$(moog wallet info --no-pretty | jq -r '.publicKey')\n</code></pre></p> <p>Now make sure you already have a Github repository for your user under your-profile-repo and add an <code>moog.vkey</code> file in the root of the repository containing your wallet public key (the <code>vkey</code> you just collected above).</p> <pre><code>export GITHUB_USERNAME=your-github-username\n</code></pre> <pre><code>set -e\ngit clone git@github.com:${GITHUB_USERNAME}/${GITHUB_USERNAME}.git\ncd ${GITHUB_USERNAME}\necho $MYPK &gt; moog.vkey\ngit add moog.vkey\ngit commit -m \"Add Antithesis wallet vkey\"\ngit push origin main\ncd ..\nrm -rf ${GITHUB_USERNAME}\n</code></pre> <p>Then register your user with the <code>moog requester register-user</code> command. <pre><code>moog requester register-user --platform github --username ${GITHUB_USERNAME} --vkey $MYPK\n</code></pre></p> <p>As with all other requests, once submitted you have to wait for the oracle to merge your request into the Antithesis token.</p> <p>You can use the <code>moog token</code> command to inspect your pending requests in the Antithesis token.</p> <p>You can use the <code>moog facts</code> command to query the Antithesis token and see if your user is part of the facts.</p> <pre><code>moog token --no-pretty | jq '.requests'\n</code></pre> <p>As long as your request is listed by <code>moog token</code>, you cannot proceed with the next steps.</p> <p>As with all requests to an MPFS you can retract your request using the <code>moog retract</code> command, anytime before the oracle merges it into the Antithesis token.</p> <p>Get the <code>outputRefId</code> of your request from pending requests command output and use it to retract your request</p> <pre><code>moog retract -o 9ec36572e01bca9f7d32d791a5a6c529ef91c10d536f662735af26311b2c8766-0\n</code></pre> <p>Currently the oracle is not able to justify a request rejection. But moog cli will apply the oracle validation before submitting it, so rejections will be caught before submitting the request.</p>"},{"location":"user/usage/#unregistering-a-user-public-key","title":"Unregistering a user public key","text":"<p>To unregister a user, you can use the <code>moog requester unregister-user</code> command.</p> <pre><code>moog requester unregister-user --platform github --username ${GITHUB_USERNAME} --vkey $MYPK\n</code></pre> <p>Unregistering will not work if the user is correcly registered. To unregister you need to falsify the registration, i.e. remove the file <code>moog.vkey</code> from your GitHub repository or change its content to a different key.</p>"},{"location":"user/usage/#unregistering-the-legacy-ssh-public-key","title":"Unregistering the legacy SSH public key.","text":"<p>In the past we supported SSH public keys for user registration. This is now deprecated and will be removed in the future. If you have an SSH public key registered, you can unregister it and register a new one with the wallet vkey. To do that, you have to unregister the SSH key first, then register the wallet vkey.</p> <pre><code>moog requester unregister-user --platform github --username ${GITHUB_USERNAME} -k $MY_SSH_PUBKEY\n</code></pre> <p>Because SSH support is deprecated, unregistering the SSH key does not require the key to be absent from GitHub, so you can unregister it even if it's still present in your GitHub account. This is to ease migration to vkey and can lead to surprises as anyone can unregister your user if you used SSH key registration.</p>"},{"location":"user/usage/#registering-a-role","title":"Registering a role","text":"<p>This is necessary to register a user as a GitHub repository antithesis test requester.</p> <p>Before you do this make sure your repository CODEOWNERS file contains a line like this:</p> <pre><code>antithesis: @your-github-username\n</code></pre> <p>CODEOWNERS file can be in the root of the repository, or in the <code>.github</code> or <code>docs</code> directories.</p> <p>You can have as many users as you want but registering them as test-run requesters has to be done one by one.</p> <p>To register a role, you can use the <code>moog requester register-role</code> command.</p> <pre><code>moog requester register-role --platform github --username alice --repository yourorg/yourrepo\n</code></pre> <p>Registering a role is not enough to gain rights to request test-runs. Your repository have to be white-listed by the agent. This requires you to get in contact with the agent and ask them to white-list your repository.</p>"},{"location":"user/usage/#unregistering-a-role","title":"Unregistering a role","text":"<pre><code>moog requester unregister-role --platform github --username alice --repository yourorg/yourrepo\n</code></pre>"},{"location":"user/usage/#test-runs","title":"Test-runs","text":""},{"location":"user/usage/#setup","title":"Setup","text":"<p>Once you are registered as a user and a role, you can request test-runs.</p> <p>Before doing that make sure you have a commit in your repository containing a directory with \"valid\" test assets inside.</p> <p>You can obtain a set of standard test assets by running the following command:</p> <p>If you are in your repository directory, you can run:</p> <pre><code>moog requester generate-assets -D ./path/to/your/test/directory\n</code></pre> <p>Once you modified them you can validate them locally using docker compose:</p> <pre><code>cd ./path/to/your/test/directory\ndocker compose config  # Validate the compose file\ndocker compose up --build  # Run locally to test\n</code></pre> <p>Then commit and push the changes to your repository so you will have a commit hash to use when requesting the test-run.</p> <p>In general your test assets directory should contain at least a <code>docker-compose.yaml</code> file with all its images published on a public registry (like DockerHub or GHCR). Any other asset in the test assets directory can be made available to any of your containers via a bind mount from the current working directory on the host.</p> <p>i.e. if you have an asset file <code>myconfig.json</code> in the test directory, it will be available to a container if you add a volume mount like this to your <code>docker-compose.yaml</code> file:</p> <pre><code>    volumes:\n      - ./myconfig.json:/etc/myapp/config.json:ro\n</code></pre>"},{"location":"user/usage/#requesting-a-test-run","title":"Requesting a test-run","text":"<p>To request a test-run, you can use the <code>moog requester create-test</code> command.</p> <pre><code>moog requester create-test --platform github --username alice --repository yourorg/yourrepo --directory ./path/to/your/test/directory --commit your_commit_hash --try 1 --duration 2\n</code></pre> <p>This command  will spit out the test-run-id (just a hash of the key) that you can use later to query the status of your test-run state.</p> <p>You can request multiple test-runs for the same commit but you have to specify a different <code>--try</code> number for each request.</p> <p>You can use the <code>--no-faults</code> option to disable the fault injector for this test-run.</p>"},{"location":"user/usage/#checking-the-test-run-status","title":"Checking the test-run status","text":"<p>You can check the status of your test-run requests with the <code>moog facts test-runs</code> command.</p> <pre><code>moog facts test-runs -i &lt;your_test_run_id&gt;\n</code></pre> <p>You can find all running test-runs for a user with</p> <pre><code>moog facts test-runs running --whose alice\n</code></pre> <p>The URL of the results is going to be encrypted so that only the requester will be able to decrypt it.</p> <p>Decryption will happen depending on the <code>MOOG_WALLET_FILE</code> environment variable to be pointing to the requester wallet.</p> <p>Old SSH registered requester will have to set up the same SSH env vars used to create the test-run.</p> <p>Careful that SSH setup will take over vkey (wallet) setup if both are setup. Remove SSH env vars once you migrate to vkey or the URL decryption will be tried via SSH.</p>"}]}